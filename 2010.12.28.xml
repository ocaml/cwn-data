<?xml version="1.0" encoding="UTF-8"?>
<cwn>
  <cwn_head>
    <cwn_date>2010.12.28</cwn_date>
    <cwn_prev>2010.12.21</cwn_prev>
    <cwn_next>2011.01.04</cwn_next>
    <cwn_date_text>December 21 to 28, 2010</cwn_date_text>
  </cwn_head>
	<cwn_body>
		<cwn_entry>
      <cwn_title>new mailing-list software for caml-list</cwn_title>
      <cwn_url>https://sympa-roc.inria.fr/wws/arc/caml-list/2010-12/msg00231.html</cwn_url>
      <cwn_who>Xavier Leroy announced</cwn_who>
      <cwn_what>
Dear subscribers,

Just to let you know that the caml-list mailing list, previously
managed by Mailman running on our development server, was migrated to
the Sympa list manager running on INRIA's dedicated,
professionally-administered mailing-list server.  Thanks are due to
Jean-Paul Chieze who performed the migration with great care.

To review and change your subscription options, please visit:
https://sympa-roc.inria.fr/wws/info/caml-list

Messages to the list should be posted to 
caml-list AT inria.fr,
 as before.
There used to be an alternate address @yquem.inria.fr which will cease
to work some time in the future, so please bookmark the @inria.fr address.

Along with the migration, we also got new Web archives for the list
(going back to its inception in the early 1990's):
https://sympa-roc.inria.fr/wws/arc/caml-list
The new archives don't look quite as good as the old ones, but at
least dates are not mangled.

Enjoy the mailing list and please be forgiving if the migration is a
bit bumpy.
      </cwn_what>
    </cwn_entry>
<cwn_entry>
      <cwn_title>ocamlnet-3.2</cwn_title>
      <cwn_url>https://sympa-roc.inria.fr/wws/arc/caml-list/2010-12/msg00239.html</cwn_url>
      <cwn_who>Gerd Stolpmann announced</cwn_who>
      <cwn_what>
A new version of ocamlnet (3.2) is ready for download and installation.
This version adds a number of features:

      * Netfs.stream_fs is the class type for a simple file system. It
        is quite minimalistic, and covers a bit more than can be done
        with the standard library (w/o Unix)
      * Netfs.local_fs is an implementation of stream_fs for accessing
        the local filesystem
      * Http_fs.http_fs is another implementation for accessing
        filesystems via HTTP
      * Shell_fs.shell_fs is another implementation for accessing
        filesystems by executing shell commands
      * There are generic algorithms for iterating and copying files
      * Netglob: is an implementation of globbing (wildcard resolution).
        It can be used for local files, but also for any stream_fs file.
      * Netmulticore is an experimental library for parallelizing code
        by using multiple processes.
      * Netconversion.user_encoding returns the current character
        encoding the user has set in the environment (locale)
      * Netsys_posix: adding the openat family of functions; adding
        fchdir; adding fdopendir

There is also a bugfix: Http_client can again take advantage from
aggressive connection caching.

Download: http://download.camlcity.org/download/ocamlnet-3.2.tar.gz

Manual:
http://projects.camlcity.org/projects/dl/ocamlnet-3.2/doc/html-main/index.html

Examples for Netmulticore:
https://godirepo.camlcity.org/svn/lib-ocamlnet2/trunk/code/examples/multicore/

Please report problems to 
gerd AT gerd-stolpmann.de

GODI users: ocamlnet-3.2 is only provided for Ocaml 3.12, and in the
ocamlnet3 overlay for Ocaml 3.11.
      </cwn_what>
    </cwn_entry>
<cwn_entry>
      <cwn_title>F# Compiler &amp; Tools Position</cwn_title>
      <cwn_url>https://sympa-roc.inria.fr/wws/arc/caml-list/2010-12/msg00240.html</cwn_url>
      <cwn_who>Don Syme announced</cwn_who>
      <cwn_what>
(It's been a while since I posted to the Caml list. My warm regards to 
everyone in the community, and best wishes for 2011)

Hi all,

The F# team are looking for a world class developer to join the team in 
Redmond.

We are seeking a talented and highly motivated software engineer with 
experience in compilers, language tools and data programming to help us ship 
the next version of F#. The ideal candidate will have a love for functional 
programming and the F# language, strong .NET programming skills including 
object-oriented techniques, knowledge of network, data and cloud programming, 
and experience of working on compilers. An interest in giving F# talks and 
working with F# users is also a strong plus, as is experience in 
data-oriented work, object/relational mappings, web services and other 
connectivity technologies. 

Above all, we're looking for people who can make significant contributions to 
the F# language implementation &amp; tools, and who can help develop the 
foundations necessary for the application of F# in the professional developer 
community. 

An MS or PhD degree in Computer Science or a related technical field is 
considered an advantage. The F# compiler is released as open source via a 
code-drop model on major releases, and experience with both large projects 
and binary/code releases on smaller, agile projects is valuable.

We'd love to hear from you! Please apply via the online forms, and feel free 
to contact myself or Joe Pamer 
(jopamer AT microsoft.com)
 for more information.  Details at 
&lt;https://careers.microsoft.com/JobDetails.aspx?ss=&amp;pg=0&amp;so=&amp;rw=1&amp;jid=30512&amp;jlang=EN&gt;.
 Applications must be submitted via the online forms.

Kind regards &amp; best wishes,
Don

Job Category: Software Engineering: Development 
Location: United States, WA, Redmond 
Job ID: 739350 30512 
Division: Server &amp; Tools Business
      </cwn_what>
    </cwn_entry>
<cwn_entry>
      <cwn_title>Job offer at LexiFi</cwn_title>
      <cwn_url>https://sympa-roc.inria.fr/wws/arc/caml-list/2010-12/msg00242.html</cwn_url>
      <cwn_who>Alain Frisch announced</cwn_who>
      <cwn_what>
LexiFi is looking to expand its team of OCaml developers.
We have many fun projects; it's a great time to join us!

The official job offer (in French) is available here:
http://www.lexifi.com/careers/jobs/fr/ingenieur_developpement

We are based in Paris area (Boulogne-Billancourt). Internships are also
possible.

Please send your cover letter and resume to 
careers AT lexifi.com
      </cwn_what>
    </cwn_entry>
<cwn_entry>
      <cwn_title>Manifest types in module type inclusions</cwn_title>
      <cwn_url>https://sympa-roc.inria.fr/wws/arc/caml-list/2010-12/msg00267.html</cwn_url>
      <cwn_who>Markus Mottl asked and Jacques Garrigue replied</cwn_who>
      <cwn_what>
&gt; please consider the following code:
&gt; 
&gt; -------------------
&gt; module M = struct type t = A | B end
&gt; 
&gt; module X : sig
&gt; (*  type t = M.t = A | B *)
&gt;  include module type of M
&gt; (*  include module type of M with type t = M.t = A | B *)
&gt; end = struct include M end
&gt; 
&gt; let () = assert (M.A = X.A)
&gt; -------------------
&gt; 
&gt; This will fail, because M.A is not of the same type as X.A.  But I
&gt; would really like to make the types equivalent.
&gt; 
&gt; Using the first commented out line instead of the module type
&gt; inclusion will succeed, but then I would not be able to automatically
&gt; include any functions potentially contained in module M.  The last
&gt; commented out line won't work, because one cannot establish a type
&gt; equivalence via a manifest type definition after "with type".  Even
&gt; if, I don't think one could override anything else but an abstract
&gt; type that way, and we are including a sum type here already.
&gt; 
&gt; Does anybody have any suggestions for a workaround?  I suspect this
&gt; may be a missing feature.

Unfortunately there is no easy workaround using 3.12.0.
Intuitively at least the 3rd line should work, but a bug prevents this.

In 3.12.1, you should be able to write either the 3rd, or the
simpler following version:

  include module type of M with type t = M.t

This should solve your problem.

Side note: the choice to make "include M" define "type t = A | B"
rather than "type t = M.t = A | B" was done to allow more implementations
(any module defining the same operations as M is allowed, rather
than modules sharing the same representation for types.)
But it resulted in not allowing the code you write here, which was
not intentional.
      </cwn_what>
    </cwn_entry>
	  <cwn_entry>
      <cwn_title>Other Caml News</cwn_title>
      <cwn_who>From the ocamlcore planet blog</cwn_who>
      <cwn_what>
Thanks to Alp Mestan, we now include in the Caml Weekly News the links to the
recent posts from the ocamlcore planet blog at &lt;http://planet.ocamlcore.org/&gt;.

References with physical equality:
  &lt;http://www.lexifi.com/blog/references-physical-equality&gt;

ocaml-extunix 0.0.2 released:
  &lt;https://forge.ocamlcore.org/forum/forum.php?forum_id=760&gt;

hypertable bindings:
  &lt;https://forge.ocamlcore.org/projects/hypertable/&gt;
      </cwn_what>
    </cwn_entry>
  </cwn_body>
</cwn>