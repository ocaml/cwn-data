<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-10-13 Tue 09:52 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OCaml Weekly News</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style type="text/css">#table-of-contents h2 { display: none } .title { display: none } .authorname { text-align: right }</style>
<style type="text/css">.outline-2 {border-top: 1px solid black;}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">OCaml Weekly News</h1>
<p>
<a href="http://alan.petitepomme.net/cwn/2020.10.06.html">Previous Week</a> <a href="http://alan.petitepomme.net/cwn/index.html">Up</a> <a href="http://alan.petitepomme.net/cwn/2020.10.20.html">Next Week</a>
</p>

<p>
Hello
</p>

<p>
Here is the latest OCaml Weekly News, for the week of October 06 to 13, 2020.
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#1">vec 0.1.0</a></li>
<li><a href="#2">Memtrace, a new memory profiler for OCaml</a></li>
<li><a href="#3">BER MetaOCaml N111, for OCaml 4.11.1</a></li>
<li><a href="#4">Clap 0.1.0 (Command-Line Argument Parsing)</a></li>
<li><a href="#5">Multicore OCaml: September 2020</a></li>
<li><a href="#6">Spin 0.7.0</a></li>
<li><a href="#7">Bootstrapping our way to Hashconsing and quotations with PPX Rewriters</a></li>
<li><a href="#8">Official shutdown date of forge.ocamlcore.org is 2020-10-18</a></li>
<li><a href="#org162d084">Old CWN</a></li>
</ul>
</div>
</div>


<div id="outline-container-org81f7dfd" class="outline-2">
<h2 id="1">vec 0.1.0</h2>
<div class="outline-text-2" id="text-1">
<p>
Archive: <a href="https://discuss.ocaml.org/t/ann-vec-0-1-0/6554/1">https://discuss.ocaml.org/t/ann-vec-0-1-0/6554/1</a>
</p>
</div>

<div id="outline-container-orga0019ce" class="outline-3">
<h3 id="orga0019ce">Alex Ionescu announced</h3>
<div class="outline-text-3" id="text-orga0019ce">
<p>
I'm happy to announce the first release of <code>vec</code>, a library for safe dynamic arrays with Rust-like
mutability permissions.
</p>

<p>
You can find the package on opam <a href="https://opam.ocaml.org/packages/vec/">here</a>, and the source
repository is <a href="https://github.com/aionescu/vec">here</a>.
</p>

<p>
Looking for feedback and suggestions!
</p>
</div>
</div>


<div id="outline-container-org8334f0c" class="outline-3">
<h3 id="org8334f0c">Josh Berdine asked and Alex Ionescu replied</h3>
<div class="outline-text-3" id="text-org8334f0c">
<blockquote>
<p>
I'm curious how you would compare this with
<a href="https://github.com/c-cube/ocaml-containers/blob/master/src/core/CCVector.ml">Containers.Vector</a>?
</p>
</blockquote>

<p>
Oh, I didn't know that existed.
Well, with <code>vec</code> you can control the vector's growth rate (though I imagine this is a very niche
feature).
</p>

<p>
Also, from what I can see CCVector's can only be read-write or read-only, <code>vec</code> also supports
write-only vectors. (Which is useful if e.g. you want to pass a buffer to some function to fill it, but
don't want the function to read its current data)
</p>
</div>
</div>


<div id="outline-container-orgd9c00d8" class="outline-3">
<h3 id="orgd9c00d8">Calascibetta Romain later said</h3>
<div class="outline-text-3" id="text-orgd9c00d8">
<p>
<code>Pvec</code> from @dbuenzli (unreleased) wants to provide a vector without the required value to initiate it
(and without <code>Obj.magic</code>). I don't know the status of it but it's quite interesting:
<a href="https://github.com/dbuenzli/pvec">https://github.com/dbuenzli/pvec</a>
</p>
</div>
</div>
</div>




<div id="outline-container-org96dbfb2" class="outline-2">
<h2 id="2">Memtrace, a new memory profiler for OCaml</h2>
<div class="outline-text-2" id="text-2">
<p>
Archive: <a href="https://discuss.ocaml.org/t/memtrace-a-new-memory-profiler-for-ocaml/6561/1">https://discuss.ocaml.org/t/memtrace-a-new-memory-profiler-for-ocaml/6561/1</a>
</p>
</div>

<div id="outline-container-org00de8cb" class="outline-3">
<h3 id="org00de8cb">Yaron Minsky announced</h3>
<div class="outline-text-3" id="text-org00de8cb">
<p>
I thought people might be interested in this post, by Luke Maurer.
</p>

<p>
<a href="https://blog.janestreet.com/finding-memory-leaks-with-memtrace/">https://blog.janestreet.com/finding-memory-leaks-with-memtrace/</a>
</p>

<p>
It announce memtrace-viewer, which is a fancy new memory profiler for OCaml, based on the new support
for statistical memory profiling, based on work by Jacques Henri-Jourdan and Stephen Dolan.
</p>

<p>
I mostly want to say: this is really good stuff. We've gotten a ton of benefit from it at Jane Street.
People have found the tool to be easy to use, and they've been able to uncover and fix a wide variety
of performance problems with it. So, try it out!
</p>

<p>
And it would be interesting for people to reply to this thread with any experience reports. I'd love to
get a better sense of the utility people are deriving from our tools outside of Jane Street.
</p>
</div>
</div>


<div id="outline-container-org75ff436" class="outline-3">
<h3 id="org75ff436">David Allsopp then added</h3>
<div class="outline-text-3" id="text-org75ff436">
<p>
This is great, thanks! I had a go with it using the native Windows ports running memtrace-viewer from
WSL. The result's a nice workflow (and a few bug fixes here and there&#x2026;), which I've <a href="https://www.dra27.uk/blog/platform/2020/10/08/windows-memtrace.html">written
up</a> here.
</p>
</div>
</div>
</div>




<div id="outline-container-org41400dc" class="outline-2">
<h2 id="3">BER MetaOCaml N111, for OCaml 4.11.1</h2>
<div class="outline-text-2" id="text-3">
<p>
Archive: <a href="https://sympa.inria.fr/sympa/arc/caml-list/2020-10/msg00007.html">https://sympa.inria.fr/sympa/arc/caml-list/2020-10/msg00007.html</a>
</p>
</div>

<div id="outline-container-org71d0aeb" class="outline-3">
<h3 id="org71d0aeb">Oleg announced</h3>
<div class="outline-text-3" id="text-org71d0aeb">
<p>
BER MetaOCaml N111 is a strict superset of OCaml 4.11.1 for ``writing
programs that generate programs''.  BER MetaOCaml adds to OCaml the
type of code values (denoting ``program code'', or future-stage
computations), and two basic constructs to build them: quoting and
splicing. The generated code can be printed, stored in a file &#x2013; or
compiled and linked-back to the running program, thus implementing
run-time code optimization. A well-typed BER MetaOCaml program
generates only well-scoped and well-typed programs: The generated code
shall compile without type errors.  Staging-annotation&#x2013;free BER
MetaOCaml is identical to OCaml; BER MetaOCaml can link to any
OCaml-compiled library (and vice versa); findlib and other tools can
be used with BER MetaOCaml as they are, in their binary form.
</p>

<p>
BER MetaOCaml N111 is a superset of the recently released OCaml
4.11.1. The significant addition is let rec insertion: the facility to
generate groups of mutually recursive definitions whose size is not
statically known. It is now possible to control the scope of
let-insertion, which is often necessary when the let-bound expression
is effectful. The well-scopedness guarantee is still
maintained. Offshoring got more polish.
</p>

<p>
As the simplest illustration of let rec insertion, the specialization
of the Ackermann function
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">ack</span> <span style="color: #a0522d;">m</span> <span style="color: #a0522d;">n</span> =
  <span style="color: #a020f0;">if</span> m = 0 <span style="color: #a020f0;">then</span> n+1 <span style="color: #a020f0;">else</span>
  <span style="color: #a020f0;">if</span> n = 0 <span style="color: #a020f0;">then</span> ack (m-1) 1 <span style="color: #a020f0;">else</span>
  ack (m-1) (ack m (n-1))
</pre>
</div>

<p>
to m=2 produces the following code
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">sac2</span> : (int -&gt; int) code = .&lt;
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">h_6</span> <span style="color: #a0522d;">n_7</span> = n_7 + 1
  <span style="color: #000000; font-weight: bold;">and</span> <span style="color: #0000ff;">h_4</span> <span style="color: #a0522d;">n_5</span> = <span style="color: #a020f0;">if</span> n_5 = 0 <span style="color: #a020f0;">then</span> h_6 1 <span style="color: #a020f0;">else</span> h_6 (h_4 (n_5 - 1))
  <span style="color: #000000; font-weight: bold;">and</span> <span style="color: #0000ff;">h_2</span> <span style="color: #a0522d;">n_3</span> = <span style="color: #a020f0;">if</span> n_3 = 0 <span style="color: #a020f0;">then</span> h_4 1 <span style="color: #a020f0;">else</span> h_4 (h_2 (n_3 - 1)) <span style="color: #000000; font-weight: bold;">in</span> h_2&gt;.
</pre>
</div>

<p>
For more explanations, please see <br />
        <a href="http://okmij.org/ftp/ML/MetaOCaml.html">http://okmij.org/ftp/ML/MetaOCaml.html</a> <br />
which now has dedicated sections on let rec insertions and offshoring.
See also ChangeLog and NOTES.txt in the BER MetaOCaml distribution.
</p>

<p>
BER MetaOCaml N111 should be available though OPAM, hopefully soon.
In the meanwhile, it is available as a set of patches to the
OCaml 4.11.1 distribution. <br />
        <a href="http://okmij.org/ftp/ML/ber-metaocaml.tar.gz">http://okmij.org/ftp/ML/ber-metaocaml.tar.gz</a> <br />
See the INSTALL document in that archive. You need the source
distribution of OCaml 4.11.1.
</p>
</div>
</div>
</div>




<div id="outline-container-org51a5ad0" class="outline-2">
<h2 id="4">Clap 0.1.0 (Command-Line Argument Parsing)</h2>
<div class="outline-text-2" id="text-4">
<p>
Archive: <a href="https://discuss.ocaml.org/t/ann-clap-0-1-0-command-line-argument-parsing/6544/3">https://discuss.ocaml.org/t/ann-clap-0-1-0-command-line-argument-parsing/6544/3</a>
</p>
</div>

<div id="outline-container-org977c98d" class="outline-3">
<h3 id="org977c98d">Continuing this thread, rbardou said</h3>
<div class="outline-text-3" id="text-org977c98d">
<p>
I did not know about minicli, thanks for the link!
</p>

<p>
Clap and minicli indeed share the same approach. Here are some differences I observed.
</p>

<ul class="org-ul">
<li>In minicli, the list of arguments is immutable; arguments are not consumed. It is "more pure".</li>

<li>As a consequence, minicli does not seem to support unnamed arguments (also known as positional arguments).</li>

<li>As another consequence, in minicli each function takes the list of arguments, which makes it a bit more flexible at the cost of being slightly more verbose.</li>

<li>In minicli there is a hash table storing the list of seen arguments. It looks like this means that the immutable list of arguments must thus always be the same if you want to call finalize, which relies on this invariant.</li>

<li>minicli does not generate a &#x2013;help (but it would be possible rather easily).</li>

<li>minicli considers that negative numbers are not option names, and is thus capable of handling them more naturally (in Clap you would need to escape the dash).</li>

<li>I think that minicli does not consider "-abc" to be equivalent to "-a -b -c", whereas Clap differentiates short names (starting with a single dash and which can be factorize like that) and long names (starting with two dashes).</li>

<li>minicli's source code is significantly shorter and thus simpler and easier to maintain.</li>
</ul>
</div>
</div>


<div id="outline-container-org8c3ab1b" class="outline-3">
<h3 id="org8c3ab1b">UnixJunkie then added</h3>
<div class="outline-text-3" id="text-org8c3ab1b">
<p>
On another topic, maybe you will be interested by parany, if you don't already know about it. :wink:
 <a href="https://github.com/UnixJunkie/parany">https://github.com/UnixJunkie/parany</a>
</p>
</div>
</div>
</div>




<div id="outline-container-orgc444824" class="outline-2">
<h2 id="5">Multicore OCaml: September 2020</h2>
<div class="outline-text-2" id="text-5">
<p>
Archive: <a href="https://discuss.ocaml.org/t/multicore-ocaml-september-2020/6565/1">https://discuss.ocaml.org/t/multicore-ocaml-september-2020/6565/1</a>
</p>
</div>

<div id="outline-container-orgf8e2727" class="outline-3">
<h3 id="orgf8e2727">Anil Madhavapeddy announced</h3>
<div class="outline-text-3" id="text-orgf8e2727">
<p>
Welcome to the September 2020 Multicore OCaml report! This update along with the <a href="https://discuss.ocaml.org/tag/multicore-monthly">previous
monthly</a> updates have been compiled by @shakthimaan,
@kayceesrk and @avsm.
</p>

<p>
Big news this month is that the <a href="https://github.com/ocaml-multicore/ocaml-multicore/pull/407">systhreads compatibility
support</a> PR has been merged, which means
that Dune (and other users of the <code>Thread</code> module) can compile out of the box.  You can now compile the
multicore OCaml fork conveniently using the new <code>opam compiler</code> plugin (<a href="https://discuss.ocaml.org/t/ann-opam-compiler-0-1-0/6442">see
announcement</a>):
</p>

<div class="org-src-container">
<pre class="src src-shell">opam update
opam compiler create <span style="color: #8b2252;">"ocaml-multicore/ocaml-multicore:no-effect-syntax"</span>
<span style="color: #483d8b;">eval</span> $(opam env)
</pre>
</div>

<p>
This selects the branch of multicore OCaml that omits the experimental <code>effect</code> syntax, and thus works
with the existing ppx ecosystem.  It's quite fun opam installing ecosystem packages and seeing them
operate out of the box at long last. There are still a few rough edges to the thread compatibility
support (mainly at the C compatibility layer, such as registering external C threads with the GC), but
these will be worked out in the coming weeks. We'd like to hear of any build failures you encounter in
the opam universe with this: please report them on
<a href="https://github.com/ocaml-multicore/ocaml-multicore/issues">https://github.com/ocaml-multicore/ocaml-multicore/issues</a>
</p>

<p>
A number of performance improvements to the multicore OCaml GC and the Sandmark benchmarking project
have also been completed through September:
</p>
<ul class="org-ul">
<li>we have now included the <a href="https://github.com/ocaml-bench/sandmark/pull/170">Kronecker implementation</a> from the Graph500 benchmarks to Sandmark - an <a href="https://github.com/ocaml-bench/sandmark/pull/173">n-queen</a> benchmark addition is in progress</li>
<li>benchmark runs now provide a count of the OCaml symbols as a code size metric</li>
<li>work on building Tezos with multicore OCaml, and integration with the Sandmark benchmarking test suite has also begun.</li>
</ul>

<p>
We have also begun an effort to <a href="https://github.com/Sudha247/lwt-multicore/tree/preemptive-multicore">port
Lwt</a> to take advantage of
parallelism via <code>Lwt_preemptive</code>. <a href="https://github.com/Sudha247/code-samples/">Code samples</a> and test
runs have been performed, and Sudha has written <a href="https://sudha247.github.io/2020/10/01/lwt-multicore/">an introductory blog
post</a> about her early results.  Note that this
work doesn't change the core behaviour of Lwt (a cooperative futures framework with no context
switching between <code>bind</code> calls), but allows parallelism via explicit calls to background preemptive
threads.
</p>

<p>
On the upstreaming efforts to OCaml, the 4.12 release will freeze earlier than usual in October, and so
we finished submitting the last of the <a href="https://github.com/ocaml/ocaml/pull/9756%20">garbage collector colour
changes</a> and are aiming for the work on reliable safe points
to go into OCaml 4.13.  There have been a lot of runtime changes packed into 4.12 already, and so we
will issue a call for testing when the release candidate of 4.12 is cut.
</p>

<p>
Onto the details of the PRs. As with the previous updates, the Multicore OCaml updates are listed
first, which are then followed by the enhancements to the Sandmark benchmarking project. The upstream
OCaml ongoing and completed updates are finally mentioned for your reference.
</p>
</div>

<div id="outline-container-orgd3d5b45" class="outline-4">
<h4 id="orgd3d5b45">Multicore OCaml</h4>
<div class="outline-text-4" id="text-orgd3d5b45">
</div>
<ul class="org-ul">
<li><a id="orgfff9193"></a>Ongoing<br />
<div class="outline-text-5" id="text-orgfff9193">
<ul class="org-ul">
<li><p>
<a href="https://github.com/ocaml-multicore/domainslib/pull/17">ocaml-multicore/domainslib#17</a>
Implement channels using Mutex and Condition Variables
</p>

<p>
The <code>lib/chan.ml</code> sources have been updated to implement channels
using Mutex and Condition Variables, and a
<code>LU_decomposition_multicore.exe</code> test has been added for the same.
</p></li>

<li><p>
<a href="https://github.com/ocaml-multicore/ocaml-multicore/pull/381">ocaml-multicore/ocaml-multicore#381</a>
Reimplementating systhreads with pthreads
</p>

<p>
This PR is actively being reviewed for the use of <code>pthreads</code> in
Multicore OCaml. It introduces the Domain Execution Contexts (DEC)
which allows multiple threads to run atop a domain.
</p></li>

<li><p>
<a href="https://github.com/ocaml-multicore/ocaml-multicore/pull/394">ocaml-multicore/ocaml-multicore#394</a>
Changes to polling placement
</p>

<p>
The polls placement is done at the start of the functions and on the
back-edge of loops, instead of using Feely's algorithm. This is a
work-in-progress.
</p></li>

<li><p>
<a href="https://github.com/ocaml-multicore/ocaml-multicore/pull/401">ocaml-multicore/ocaml-multicore#401</a>
Do not handle interrupts recursively
</p>

<p>
A domain local variable is introduced to prevent handling of
interrupts recursively.
</p></li>

<li><p>
<a href="https://github.com/ocaml-multicore/ocaml-multicore/pull/402">ocaml-multicore/ocaml-multicore#402</a>
Split handle_gc_interrupt into handling remote and polling sections
</p>

<p>
A <code>caml_poll_gc_work</code> is introduced that has information of GC work
done previously in <code>caml_handle_gc_interrupt</code>. This facilitates
<code>stw_handler</code> to make calls to poll and not handle service
interrupts, as it may lead to unwanted recursion.
</p></li>

<li><p>
<a href="https://github.com/ocaml-multicore/ocaml-multicore/issues/403">ocaml-multicore/ocaml-multicore#403</a>
Segmentation fault when building Tezos on Multicore 4.10.0 with no-effects-syntax
</p>

<p>
This is an on-going investigation on why the package
<code>tezos-embedded-protocol-packer</code> in Tezos is causing a segmentation
fault when building with Multicore OCaml.
</p></li>
</ul>
</div>
</li>

<li><a id="orgad9c28a"></a>Completed<br />
<ul class="org-ul">
<li><a id="org70b1c00"></a>Domainslib<br />
<div class="outline-text-6" id="text-org70b1c00">
<ul class="org-ul">
<li><p>
<a href="https://github.com/ocaml-multicore/domainslib/pull/19">ocaml-multicore/domainslib#19</a>
Finer grain signalling with mutex condvar for Channels
</p>

<p>
The use of fine grain locking for Mutex and condition variables
helps in improving the performance for larger cores, as against a
single mutex for all the signalling.
</p></li>
</ul>
</div>
</li>

<li><a id="orgf783fb6"></a>Multicore OPAM<br />
<div class="outline-text-6" id="text-orgf783fb6">
<ul class="org-ul">
<li><p>
<a href="https://github.com/ocaml-multicore/multicore-opam/pull/31">ocaml-multicore/multicore-opam#31</a>
Patch dune.2.7.1 for Multicore OCaml
</p>

<p>
The opam file for dune.2.7.1 has been added along with a patch to
<code>bootstrap.ml</code> to get it working for Multicore OCaml, thanks to
Chaitanya Koparkar.
</p></li>

<li><p>
<a href="https://github.com/ocaml-multicore/multicore-opam/pull/32">ocaml-multicore/multicore-opam#32</a>
Add ocamlfind-secondary dependency to dune
</p>

<p>
The installation of <code>dune</code> requires <code>ocamlfind-secondary</code> as a
dependency for dune.2.7.1, and has been added to the OPAM file.
</p></li>
</ul>
</div>
</li>

<li><a id="orgf44c00a"></a>Multicore OCaml<br />
<div class="outline-text-6" id="text-orgf44c00a">
<ul class="org-ul">
<li><p>
<a href="https://github.com/ocaml-multicore/ocaml-multicore/pull/395">ocaml-multicore/ocaml-multicore#395</a>
Move to SPIN_WAIT for all spins and usleep in SPIN_WAIT
</p>

<p>
The PR provides the SPIN_WAIT macro for all the busy spin wait
loops, and uses <code>caml_plat_spin_wait</code> when busy waiting. This
ensures that the same spin strategy is used in different places in
the code.
</p></li>

<li><p>
<a href="https://github.com/ocaml-multicore/ocaml-multicore/pull/397">ocaml-multicore/ocaml-multicore#397</a>
Relaxation of backup thread signalling
</p>

<p>
The signalling to the backup thread from the mutator thread when
leaving a blocking section is modified. It reduces the potential
Operating System scheduling when re-entering OCaml.
</p></li>

<li><p>
<a href="https://github.com/ocaml-multicore/ocaml-multicore/pull/400">ocaml-multicore/ocaml-multicore#400</a>
Demux eventlog for backup thread
</p>

<p>
The events in the backup thread were emitting the same process ID as
the main thread, and this PR separates them.
</p>


<div class="figure">
<p><img src="https://aws1.discourse-cdn.com/standard11/uploads/ocaml/optimized/2X/0/09456772484b8be0899c9812f634816da4db5e7d_2_1380x492.png" alt="09456772484b8be0899c9812f634816da4db5e7d_2_1380x492.png" />
</p>
</div>

<p>
In the above illustration, the backup threads are active when the
main thread is waiting on a condition variable.
</p></li>
</ul>
</div>
</li>
</ul>
</li>
</ul>
</div>

<div id="outline-container-org52e310e" class="outline-4">
<h4 id="org52e310e">Benchmarking</h4>
<div class="outline-text-4" id="text-org52e310e">
</div>
<ul class="org-ul">
<li><a id="org10355e6"></a>Ongoing<br />
<div class="outline-text-5" id="text-org10355e6">
<ul class="org-ul">
<li><p>
<a href="https://github.com/ocaml-bench/sandmark/issues/159">ocaml-bench/sandmark#159</a>
Implement a better way to describe tasklet cpulist
</p>

<p>
We need a cleaner way to obtain the taskset list of cores for a
benchmark run when we are provided with a number of domains. We
should be able to specify hyper-threaded cores, NUMA zones to use,
and the specific cores to use for the parallel benchmarks.
</p></li>

<li><p>
<a href="https://github.com/ocaml-bench/sandmark/pull/173">ocaml-bench/sandmark#173</a>
Addition of nqueens benchmark to multicore-numerical
</p>

<p>
A draft version of the classical <code>n queens</code> benchmark has been added
for review in Sandmark. This includes both the single and multicore
implementation.
</p></li>
</ul>
</div>
</li>

<li><a id="org4c05b3e"></a>Completed<br />
<div class="outline-text-5" id="text-org4c05b3e">
<ul class="org-ul">
<li><p>
<a href="https://github.com/ocaml-bench/ocaml_bench_scripts/pull/11">ocaml-bench/ocaml_bench_scripts#11</a>
Add support for configure option and OCAMLRUNPARAM
</p>

<p>
The <code>ocaml_bench_scripts</code> has been updated to support passing
<code>configure</code> options and OCAMLRUNPARAM when building and running the
benchmarks in Sandmark.
</p></li>

<li><p>
<a href="https://github.com/ocaml-bench/sandmark/issues/122">ocaml-bench/sandmark#122</a>
Measurements of code size
</p>

<p>
The output .bench JSON file produced from the benchmarks now
includes a code size metric for the number of CAML symbols. A sample
benchmark output is shown below:
</p>

<div class="org-src-container">
<pre class="src src-json">{"name":"knucleotide.", ... ,"codesize":276859.0, ...}
</pre>
</div>

<p>
The code size count for few of the benchmarks is given below:
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Benchmark</th>
<th scope="col" class="org-left">Count</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">alt-ergo</td>
<td class="org-left">2_822_040</td>
</tr>

<tr>
<td class="org-left">coqc</td>
<td class="org-left">5_869_305</td>
</tr>

<tr>
<td class="org-left">cpdf</td>
<td class="org-left">1_131_376</td>
</tr>

<tr>
<td class="org-left">nbody.exe</td>
<td class="org-left">276_710</td>
</tr>

<tr>
<td class="org-left">stress.exe</td>
<td class="org-left">84_061</td>
</tr>

<tr>
<td class="org-left">fft.exe</td>
<td class="org-left">38_914</td>
</tr>
</tbody>
</table></li>

<li><p>
<a href="https://github.com/ocaml-bench/sandmark/pull/170">ocaml-bench/sandmark#170</a>
Graph500 SEQ
</p>

<p>
The Graph500 benchmark with a Kronecker graph generator has now been
added to Sandmark. The generator builds three kernels for graph
construction, Breadth First Search, and Single Source Shortest
Paths.
</p></li>

<li><p>
<a href="https://github.com/ocaml-bench/sandmark/pull/172">ocaml-bench/sandmark#172</a>
Remove <code>Base</code>, <code>Stdio</code> orun dependency for trunk
</p>

<p>
The <code>orun</code> sources in Sandmark have been updated to remove the
dependency on both <code>Base</code> and <code>Stdio</code>. They have been replaced with
functions from <code>Stdlib</code>, <code>List</code>, <code>String</code> and <code>Str</code>.
</p></li>

<li><p>
<a href="https://github.com/ocaml-bench/sandmark/pull/174">ocaml-bench/sandmark#174</a>
Cleanup our use of sudo for chrt
</p>

<p>
The use of <code>sudo</code> has been removed from the Makefile for running
parallel benchmarks, to avoid creating output files and directories
that require root permissions for access. The use of
<code>RUN_BENCH_TARGET=run_orunchrt</code> will execute the benchmarks using
<code>chrt -r 1</code>. The user can give permissions to the <code>chrt</code> binary
using:
</p>

<div class="org-src-container">
<pre class="src src-shell">sudo setcap <span style="color: #a0522d;">cap_sys_nice</span>=ep /usr/bin/chrt
</pre>
</div></li>
</ul>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgdca9405" class="outline-4">
<h4 id="orgdca9405">OCaml</h4>
<div class="outline-text-4" id="text-orgdca9405">
</div>
<ul class="org-ul">
<li><a id="org219b1de"></a>Ongoing<br />
<div class="outline-text-5" id="text-org219b1de">
<ul class="org-ul">
<li><p>
<a href="https://github.com/ocaml/ocaml/pull/9876">ocaml/ocaml#9876</a>
Do not cache young_limit in a processor register
</p>

<p>
The PR removes the caching of <code>young_limit</code> in a register for ARM64,
PowerPC and RISC-V ports, as it is problematic during polling for
signals and inter-domain communication in Multicore OCaml.
</p></li>
</ul>
</div>
</li>

<li><a id="org3e55c57"></a>Completed<br />
<div class="outline-text-5" id="text-org3e55c57">
<ul class="org-ul">
<li><p>
<a href="https://github.com/ocaml/ocaml/pull/9756">ocaml/ocaml#9756</a>
Garbage collectors colour change
</p>

<p>
The gray colour scheme in the Garbage Collector has been removed to
facilitate merging with the Multicore OCaml collector. The existing
benchmarks in Sandmark suite that did overflow the mark stack are
show in the below illustration, and there is little negative impact
on the change.
 <img src="https://aws1.discourse-cdn.com/standard11/uploads/ocaml/optimized/2X/1/10b2ae2b0f7cffe0148ee97b828ded5d4ed36a21_2_1380x990.png" alt="10b2ae2b0f7cffe0148ee97b828ded5d4ed36a21_2_1380x990.png" />
</p></li>
</ul>

<p>
As always, we would like to thank all the OCaml developers and users in the community for their
continued support and contribution to the project.  Be well!
</p>
</div>
</li>
</ul>
</div>

<div id="outline-container-org755fa76" class="outline-4">
<h4 id="org755fa76">Acronyms</h4>
<div class="outline-text-4" id="text-org755fa76">
<ul class="org-ul">
<li>ARM: Advanced RISC Machine</li>
<li>BFS: Breadth First Search</li>
<li>DEC: Domain Execution Context</li>
<li>GC: Garbage Collector</li>
<li>JSON: JavaScript Object Notation</li>
<li>NUMA: Non-Uniform Memory Access</li>
<li>OPAM: OCaml Package Manager</li>
<li>OS: Operating System</li>
<li>PR: Pull Request</li>
<li>RISC-V: Reduced Instruction Set Computing - V</li>
<li>SSSP: Single Source Shortest Path</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orge340bc6" class="outline-3">
<h3 id="orge340bc6">sid asked and Anil Madhavapeddy replied</h3>
<div class="outline-text-3" id="text-orge340bc6">
<blockquote>
<p>
Curious to know: How will merging multicore as a whole work? Until now PRs that are relevant for
multicore are being merged gradually into the main OCaml repo. These PRs tend to be smallish mostly
(with some exceptions).
</p>

<p>
But the multicore project has thousands of lines of new code. How will that code be broken up into
separate and digestible chunks to get merged? If each of those PRs go through the traditional review
process there could be further changes required in multicore itself. I understand everything is finely
balanced so this could end up causing issues. Alternatively will will the multicore repo become the
main repo (I guess that would be unlikely).
</p>
</blockquote>

<p>
That's a good question @sid. Once all the various architectural dependencies are in place, the GC
itself is just a few standalone C files.  The current plan is just to do focussed review from the core
development team to that particular PR, with plenty of time in the development cycle to facilitate
changes.  The intention is to branch to OCaml 5.0 when the domains-only support lands, OCaml 4.x
maintained as a longer term support branch while the 5.x series settles down.  This is a major enough
change that we are expecting some deviance from the release cadence of the past few years.
</p>

<p>
The multicore repo will definitely not become the main OCaml repo. We are reimplementing clean PRs for
upstream OCaml, as the multicore repo history is long, storied and not especially useful.
</p>

<blockquote>
<p>
Generally curious how the “end game” will play out…
</p>
</blockquote>

<p>
It's also just the beginning of the game :-) I'm very excited about some of the ongoing developments
for post 5.0, such as fibres and effects.  We'll have more details (and paper drafts) on that as the
research dust settles over the next few quarters.
</p>
</div>
</div>
</div>




<div id="outline-container-org37c0c5c" class="outline-2">
<h2 id="6">Spin 0.7.0</h2>
<div class="outline-text-2" id="text-6">
<p>
Archive: <a href="https://discuss.ocaml.org/t/ann-spin-0-7-0/6569/1">https://discuss.ocaml.org/t/ann-spin-0-7-0/6569/1</a>
</p>
</div>

<div id="outline-container-org516e581" class="outline-3">
<h3 id="org516e581">Thibaut Mattio announced</h3>
<div class="outline-text-3" id="text-org516e581">
<p>
I'm happy to announce a new version of <a href="https://github.com/tmattio/spin">Spin</a> (0.7.0).
</p>

<p>
This release comes with a new official template <code>spa</code>, to generate Single Page Applications with
Js_of_ocaml.
</p>

<p>
It also removes the dependency on Reason, so Spin is now compatibility with OCaml 4.11.
</p>

<p>
Here's the complete list of changes: <a href="https://github.com/tmattio/spin/releases/tag/0.7.0">https://github.com/tmattio/spin/releases/tag/0.7.0</a>
</p>

<p>
Not part of this release, but I thought I'd mention it, I created two non-official templates:
</p>

<ul class="org-ul">
<li><a href="https://github.com/tmattio/spin-rescript"><code>spin-rescript</code></a> - a template to generate ReScript projects</li>
<li><a href="https://github.com/tmattio/spin-jsoo-react/"><code>spin-jsoo-react</code></a> - a template to generate React applications with Js_of_ocaml</li>
</ul>

<p>
If you have any feedback or suggestions, don't hesitate to open an
<a href="https://github.com/tmattio/spin/issues">issue</a>.
</p>
</div>
</div>
</div>




<div id="outline-container-orga12d33d" class="outline-2">
<h2 id="7">Bootstrapping our way to Hashconsing and quotations with PPX Rewriters</h2>
<div class="outline-text-2" id="text-7">
<p>
Archive: <a href="https://discuss.ocaml.org/t/bootstrapping-our-way-to-hashconsing-and-quotations-with-ppx-rewriters/6574/1">https://discuss.ocaml.org/t/bootstrapping-our-way-to-hashconsing-and-quotations-with-ppx-rewriters/6574/1</a>
</p>
</div>

<div id="outline-container-org2b97b87" class="outline-3">
<h3 id="org2b97b87">Chet Murthy announced</h3>
<div class="outline-text-3" id="text-org2b97b87">
<p>
This post is about PPX rewriters, using multiple of them in sequence,
using one rewriter in implementing others, and getting to something
&#x2026;. somewhat surprisingly complex, in simple steps.  All of this has
been done using PPX rewriters based on <code>camlp5</code> (and <code>pa_ppx</code>), but
should in principle be doable on <code>ppxlib</code> (the standard support
infrastructure for PPX rewriters).
</p>

<p>
I should note that the portions regarding hash-consing are all a
pretty faithful re-implementation and mechanization of the paper of
Filliatre and Conchon:
<a href="https://www.lri.fr/~filliatr/ftp/publis/hash-consing2.pdf">Type-Safe Modular Hash-Consing</a>.
All errors are mine, of course.
</p>

<p>
TL;DR This post describes how, starting with an AST type and a parser
for it, we can more-or-less automatically generate
</p>

<ul class="org-ul">
<li>hash-consed versions of the AST,</li>
<li>functions back-and-forth,</li>
<li>and surface-syntax "quotation" expanders for both types</li>
</ul>

<p>
so that code doesn't need to manipulate the AST directly, but can
instead use the surface syntax (hence being more-or-less indifferent
to whether it's applied to the original or hashconsed version of the
AST).
</p>

<p>
All of the code discussed here is available on github at:
<a href="https://github.com/camlp5">https://github.com/camlp5</a> , in projects <code>camlp5/pa_ppx</code>,
<code>camlp5/pa_ppx_{migrate,hashcons,q_ast,params}</code>.  The latter ones are
not (yet) released on OPAM, but will be soon.  I apologize in advance
for the nonexistent-to-poor documentation: I'm working on it!  Working
code for everything described below can be found at
<code>camlp5/pa_ppx_q_ast/tests</code>, in the directories <code>sexp_example</code> and
<code>eg_sexp_example</code>.
</p>
</div>

<div id="outline-container-org32baf4c" class="outline-4">
<h4 id="org32baf4c">Motivation (a Concrete Example)</h4>
<div class="outline-text-4" id="text-org32baf4c">
<p>
The ability to transparently introduce hash-consing into a complex
collection of AST types should need no argument.  The ability to use
"quotations" over such an AST type might need some motivation.  So
consider a type of s-expressions, viz
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">sexp</span> =
    <span style="color: #000000; background-color: #ffffff;">Atom</span> <span style="color: #a020f0;">of</span> string
  | <span style="color: #000000; background-color: #ffffff;">Cons</span> <span style="color: #a020f0;">of</span> sexp * sexp
  | Nil
</pre>
</div>

<p>
with the obvious parsing that we're all used-to from LISP/Scheme.  The
hashconsed version of this type is
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">sexp_node</span> =
    <span style="color: #000000; background-color: #ffffff;">Atom</span> <span style="color: #a020f0;">of</span> string
  | <span style="color: #000000; background-color: #ffffff;">Cons</span> <span style="color: #a020f0;">of</span> sexp * sexp
  | <span style="color: #000000; background-color: #ffffff;">Nil</span>
<span style="color: #000000; font-weight: bold;">and</span> <span style="color: #a0522d;">sexp</span> = sexp_node hash_consed
</pre>
</div>

<p>
with (from the opam package <code>hashcons</code>)
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">+'a hash_consed</span> = <span style="color: #a020f0;">private</span> {
  hkey : int;
  tag : int;
  node : 'a }
</pre>
</div>

<p>
NOTE: there is a nuance here that I'll address at the end of ths post
in the section "Appendix B: Types with and without <code>vala</code>".
</p>

<p>
Let's suppose we want to write the function <code>atoms : sexp -&gt; string
list</code> that returns the list of <code>string</code> (those wrapped by <code>Atom</code>) at the
leaves of the s-expression.  The code is easy enough (just rotate
left-child cons-nodes to the right, until we get an atom (or Nil) and
then move on to the cdr.  This is a good example to consider, because
it requires multi-level pattern-matching and multi-level
constructor-expressions.  So the introduction of meaningless
bureaucracy will be palpable.
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a0522d;">atoms</span> =
  <span style="color: #a020f0;">function</span>
    <span style="color: #000000; background-color: #ffffff;">Nil</span> -&gt; <span style="color: #000000; background-color: #ffffff;">[]</span>
  | <span style="color: #000000; background-color: #ffffff;">Atom</span> a -&gt; [a]
  | <span style="color: #000000; background-color: #ffffff;">Cons</span>(<span style="color: #000000; background-color: #ffffff;">Cons</span>(caar, cdar), cdr) -&gt;
      atoms (<span style="color: #000000; background-color: #ffffff;">Cons</span>(caar, <span style="color: #000000; background-color: #ffffff;">Cons</span> (cdar, cdr)))
  | <span style="color: #000000; background-color: #ffffff;">Cons</span>(<span style="color: #000000; background-color: #ffffff;">Nil</span>, cdr) -&gt; atoms cdr
  | <span style="color: #000000; background-color: #ffffff;">Cons</span>(<span style="color: #000000; background-color: #ffffff;">Atom</span> a, cdr) -&gt; a <span style="color: #000000; background-color: #ffffff;">::</span> atoms cdr
</pre>
</div>

<p>
and the hashconsed version is
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #a0522d;">atoms</span> =
  <span style="color: #a020f0;">function</span>
    {node = <span style="color: #000000; background-color: #ffffff;">Nil</span>} -&gt; <span style="color: #000000; background-color: #ffffff;">[]</span>
  | {node = <span style="color: #000000; background-color: #ffffff;">Atom</span> a} -&gt; [a]
  | {node = <span style="color: #000000; background-color: #ffffff;">Cons</span>({node = <span style="color: #000000; background-color: #ffffff;">Nil</span>}, cdr)} -&gt; atoms cdr
  | {node = <span style="color: #000000; background-color: #ffffff;">Cons</span>({node = <span style="color: #000000; background-color: #ffffff;">Atom</span> a}, cdr)} -&gt; a <span style="color: #000000; background-color: #ffffff;">::</span> atoms cdr
  | {node = <span style="color: #000000; background-color: #ffffff;">Cons</span> ({node = <span style="color: #000000; background-color: #ffffff;">Cons</span> (caar, cdar)}, cdr)} -&gt;
      atoms (make_sexp (<span style="color: #000000; background-color: #ffffff;">Cons</span> (caar, (make_sexp (<span style="color: #000000; background-color: #ffffff;">Cons</span> (cdar, cdr))))))
</pre>
</div>

<p>
As you can see, there are extra patterns <code>{ node = ...}</code> and a new
constructor <code>make_sexp</code> (to perform the actual hashtable lookup &amp;
consing).  And these extra bits appear at multiple levels in both
patterns and expressions.
</p>

<p>
Wouldn't it be nice, if we could write one version of this code, viz.
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">atoms</span> = <span style="color: #a020f0;">function</span>
    &lt;:sexp&lt; () &gt;&gt; -&gt; <span style="color: #000000; background-color: #ffffff;">[]</span>
  | &lt;:sexp&lt; <span style="color: #a52a2a;">$</span>atom:a<span style="color: #a52a2a;">$</span> &gt;&gt; -&gt; [a]
  | &lt;:sexp&lt; ( () . <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">cdr$ </span>) &gt;&gt; -&gt; atoms cdr
  | &lt;:sexp&lt; ( <span style="color: #a52a2a;">$</span>atom:a<span style="color: #a52a2a;">$</span> . <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">cdr$ </span>) &gt;&gt; -&gt; a<span style="color: #000000; background-color: #ffffff;">::</span>(atoms cdr)
  | &lt;:sexp&lt; ( ( <span style="color: #a52a2a;">$</span>exp:caar<span style="color: #a52a2a;">$</span> . <span style="color: #a52a2a;">$</span>exp:cdar<span style="color: #a52a2a;">$</span> ) . <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">cdr$ </span>) &gt;&gt; -&gt;
    atoms &lt;:sexp&lt; ( <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">caar$ . ( $exp:cdar$ . $exp:cdr$ ) </span>) &gt;&gt;
</pre>
</div>

<p>
and merely by changing "&lt;:sexp&lt;" to "&lt;:hcsexp&lt;" get a version of the
function that works on hashconsed s-expressions?  The text within
<code>&lt;:sexp&lt; .... &gt;&gt;</code> is called a "quotation" in Camlp5, and is similar to
the same concept in <code>ppx_metaquot</code> and the much older LISP idea of
"quasi-quotation".  The contained text is parsed with a parser for
s-expressions, slightly modified to have indications for where the
text <code>$...$</code> may appear &#x2013; these are called "anti-quotations', and can
contain OCaml source code (e.g. variables) albeit not quotations (so
no arbitrary nesting).  The "quotation expander" parses this text to
AST and applies a converter to produce an OCaml expression or pattern
AST that does what the quotation intends.  The lovely thing is, by
changing out the quotation-expander (replace "sexp" with "hcsexp") we
can change the code that is generated, and if the quotation-expander
is generated from the type definition, it's not actually any work for
the programmer to achieve this.
</p>

<p>
NOTE: Unlike with <code>ppx_metaquot</code>, the antiquotations can be placed in
nearly-arbitrary positions in the parse-tree (hence, in the AST):
there is no requirement that they correspond to variable-names or
identifiers in the OCaml AST: indeed, our running example will <b>not</b>
be the OCaml AST, even though all of this machinery has been
applied-to the OCaml AST successfully.
</p>

<p>
In this post I'll walk you thru how to achieve this goal: building up
the machinery, step-by-step, to allow one to write basically arbitrary
expressions in your AST's surface syntax, and automatically get either
"normal' (no hash-consing) or "hashconsed" patterns &amp; expressions.
</p>
</div>
</div>

<div id="outline-container-orgfa6b0e5" class="outline-4">
<h4 id="orgfa6b0e5">A High-Level Plan of Attack</h4>
<div class="outline-text-4" id="text-orgfa6b0e5">
<p>
A while back in the "Future of PPX" post (
<a href="https://discuss.ocaml.org/t/the-future-of-ppx/3766">https://discuss.ocaml.org/t/the-future-of-ppx/3766</a> ) there was some
discussion of hash-consing for ASTs, and the complexities of achieving
it.  I wrote a reply post "Hashconsing an AST via PPX" (
<a href="https://discuss.ocaml.org/t/hashconsing-an-ast-via-ppx/5558">https://discuss.ocaml.org/t/hashconsing-an-ast-via-ppx/5558</a> ) where I
showed how one could use a PPX rewriter to automate the task of
"re-sharing" an AST when writing a top-down/bottom-up rewriter for an
AST. (That is, you're walking an AST, making small modifications, but
most of it stays the same; so in principle, at a node <code>Add(Mul(e1,e2),
e3)</code> when rewriting <code>e3</code> actually changes it visibly, but <code>Mul(e1,e2)</code>
doesn't, we might want the output value's first subtree to be
pointer-equal to the input's first subtree.)  I called this
"rehashcons"ing (admittedly not a great name).  The idea being,
<code>rehashcons</code> is not trying to hash-cons, but only to restore whatever
sharing was there originally, to whatever extent that's possible.
</p>

<p>
But this is neither sufficient in all cases, nor real hash-consing.
The problem with hash-consing is::
</p>

<p>
A. If you start with an AST type that doesn't have the various bits
   needed for hash-consing (at a minimum, a type <code>'a node = { it : 'a
   ; hashcode : int }</code> and its use at each spot where we want to
   hash-cons) then you have to first <b>produce a new AST type</b> with those bits
   inserted.  Let's call these the "normal" and "hashconsed" ASTs.
</p>

<p>
B. You have to write tons of boilerplate code: first, to map
   to-and-from these two type-families, and second to <b>implement</b> the
   hash-consing (special constructors, (ephemeral) hashtables
   here-and-there, etc). Then perhaps you'd like to memoize functions
   over these hash-consed ASTs, and that's more boilerplate.
</p>

<p>
C. And then, when it comes to writing expressions and patterns over
   this new AST type, you have to remember where the "special bits" go
   &#x2013; where to insert the special constructors, and where to add
   <code>{it=....}</code> to patterns.
</p>

<p>
It's all a bit of a tedious bother, when what we <b>want</b> is to just
manipulate the hashconsed data-type as if it were the "normal" type,
and have the messy bits filled-in for us.
</p>

<p>
This post is about how to achieve that.
</p>
</div>
</div>

<div id="outline-container-org19a9830" class="outline-4">
<h4 id="org19a9830">A plan for how to achieve reasonably transparent hash-consing</h4>
<div class="outline-text-4" id="text-org19a9830">
<p>
Let's first map out the plan of attack:
</p>

<ol class="org-ol">
<li>Start with an AST type (or types) for our language, and a parser
(in this case, written using Camlp5's grammar machinery).</li>

<li>Add to the AST type some indications for where antiquotations may
go, and modify the parser to parse these antiquotations.  We'll
call this the "normal" AST type.  Note that this is the version
<b>with</b> antiquotation markers.</li>

<li><code>pa_ppx_hashcons</code> Generate a <b>hashconsed version of the AST type</b> from the
"normal" AST type.</li>

<li><code>pa_ppx_migrate</code> Generate functions back-and-forth between "normal" and "hashconsed"
versions of the AST type.  So we're hashconsing the version <b>with</b>
antiquotation markers.  We could hashcons the version without
antiquotation markers, and everything here would still work out
&#x2026; but it would be more complicated to explain.</li>

<li><code>pa_ppx_q_ast</code> From each of the "normal" and "hashconsed" AST types, generate
functions that can take values of the type and generate OCaml code
for patterns and expressions that correspond to those values.</li>

<li><p>
<code>pa_ppx.deriving_plugins.params</code> In implementing the above, we're
describing complex tasks, so it's possible that when not
automatically inferrable from types, the "hints" we might need to
give will be complex.  It would be nice if there were a way to
automatically generate code to parse such specifications.  If we
were writing some other application, we might want to use
<code>ppx_deriving.yojson</code> (or our equivalent,
<code>pa_ppx.deriving_plugins.yojson</code>) and write our specification in
JSON.  But since we're writing a PPX rewriter, the specification
will come in the payload of a PPX attribute/extension.  Since our
"hints" might need to contain types and expressions, we'd probably
like the payload to be real expressions and types.  So what we need
is a type-driven mapping from expression-ASTs, to expressions.
</p>

<p>
Then, when implementing a PPX rewriter, we can write down the type
of its "params", and from that generate the function that will
convert expression-ASTs to that type.
</p></li>
</ol>

<p>
The implementation of all of the above, is what I will describe in the
rest of this note.  I've applied it to
</p>

<ul class="org-ul">
<li>(simple) s-expressions</li>
<li>(simple) deBruijn lambda-terms</li>
<li>(simple) named-variable lambda-terms</li>
<li>(complex and comprehensive) the entire OCaml AST in Camlp5.</li>
</ul>
</div>
</div>

<div id="outline-container-orgaffece9" class="outline-4">
<h4 id="orgaffece9">A Worked Example: s-expressions.</h4>
<div class="outline-text-4" id="text-orgaffece9">
<p>
In this section, I'll work thru how to apply the ideas above,
step-by-step, to s-expressions.  Everything described here is working
code, documented and tested in
<code>camlp5/pa_ppx_q_ast/tests/{sexp_example,eg_sexp_example}</code>.
</p>
</div>

<ul class="org-ul">
<li><a id="org5131339"></a>0. Write the AST type (without antiquotations)<br />
<div class="outline-text-5" id="text-org5131339">
<p>
Copying from above
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">sexp</span> =
    <span style="color: #000000; background-color: #ffffff;">Atom</span> <span style="color: #a020f0;">of</span> string
  | <span style="color: #000000; background-color: #ffffff;">Cons</span> <span style="color: #a020f0;">of</span> sexp * sexp
  | Nil
</pre>
</div>
</div>
</li>

<li><a id="org1614a32"></a>1. Add antiquotation markers and add a parser<br />
<div class="outline-text-5" id="text-org1614a32">
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">sexp</span> =
    <span style="color: #000000; background-color: #ffffff;">Atom</span> <span style="color: #a020f0;">of</span> (string vala)
  | <span style="color: #000000; background-color: #ffffff;">Cons</span> <span style="color: #a020f0;">of</span> (sexp vala) * (sexp vala)
  | Nil
</pre>
</div>

<p>
The type <code>'a vala</code> is a Camlp5 type-constructor.  It contains either
a value of type <code>'a</code>, or an antiquotation.  A short argument for why
antiquotations markers are necessary, can be found in "Appendix C: Is
<code>vala</code> Necessary?"
</p>

<p>
Here's the parser:
</p>

<div class="org-src-container">
<pre class="src src-ocaml">sexp: [
  [
    a = <span style="color: #000000; background-color: #ffffff;">V</span> atom <span style="color: #8b2252;">"atom"</span> -&gt; sexp_atom a
  | <span style="color: #8b2252;">"("</span> ; l1 = <span style="color: #000000; background-color: #ffffff;">LIST1</span> v_sexp ; opt_e2 = <span style="color: #000000; background-color: #ffffff;">OPT</span> [ <span style="color: #8b2252;">"."</span> ; e2 = v_sexp -&gt; e2 ] ; <span style="color: #8b2252;">")"</span> -&gt;
    <span style="color: #a020f0;">match</span> opt_e2 <span style="color: #a020f0;">with</span> [
      <span style="color: #000000; background-color: #ffffff;">None</span> -&gt; <span style="color: #228b22;">List.</span>fold_right (<span style="color: #a020f0;">fun</span> <span style="color: #a0522d;">vse1</span> <span style="color: #a0522d;">se2</span> -&gt; <span style="color: #228b22;">Sexp.</span><span style="color: #000000; background-color: #ffffff;">Cons</span> vse1 &lt;:vala&lt; se2 &gt;&gt;) l1 sexp_nil
    | <span style="color: #000000; background-color: #ffffff;">Some</span> ve2 -&gt;
       <span style="color: #000000; font-weight: bold;">let</span> (<span style="color: #a0522d;">last</span>, <span style="color: #a0522d;">l1</span>) = sep_last l1 <span style="color: #000000; font-weight: bold;">in</span>
       <span style="color: #228b22;">List.</span>fold_right (<span style="color: #a020f0;">fun</span> <span style="color: #a0522d;">vse1</span> <span style="color: #a0522d;">se2</span> -&gt; <span style="color: #228b22;">Sexp.</span><span style="color: #000000; background-color: #ffffff;">Cons</span> vse1 &lt;:vala&lt; se2 &gt;&gt;) l1
         (<span style="color: #228b22;">Sexp.</span><span style="color: #000000; background-color: #ffffff;">Cons</span> last ve2)
    ]
  | <span style="color: #8b2252;">"("</span> ; <span style="color: #8b2252;">")"</span> -&gt;
      sexp_nil
  ]
]
;

v_sexp: [[ v = <span style="color: #000000; background-color: #ffffff;">V</span> sexp <span style="color: #8b2252;">"exp"</span> -&gt; v ]];

atom: [[ i = <span style="color: #000000; background-color: #ffffff;">LIDENT</span> -&gt; i | i = <span style="color: #000000; background-color: #ffffff;">UIDENT</span> -&gt; i | i = <span style="color: #000000; background-color: #ffffff;">INT</span> -&gt; i ]] ;

sexp_eoi: [ [ x = sexp; <span style="color: #000000; background-color: #ffffff;">EOI</span> -&gt; x ] ];
</pre>
</div>

<p>
This is an LL(1) grammar, interpreted by Camlp5, and the marker for
antiquotations is "V".  Full details of the grammar language can be
found in the Camlp5 documentation.  You can see in it, that we've used
<code>V sexp "exp"</code> (renamed for convenience to "v_sexp") everywhere
internally, and that <code>Atom</code> is parsed by <code>V atom "atom"</code> (again,
giving an antiquotation position.).
</p>
</div>
</li>

<li><a id="orgd58e6b5"></a>2. Generate a Hashconsed version of the AST type<br />
<div class="outline-text-5" id="text-orgd58e6b5">
<p>
This is the input to the <code>camlp5/pa_ppx_hashcons</code> PPX rewriter.  This
rewriter implements the method of Jean-Christophe Filliatre and
Sylvain Conchon, from their paper
<a href="https://www.lri.fr/~filliatr/ftp/publis/hash-consing2.pdf">Type-Safe Modular Hash-Consing</a>.
In short, we specify a few module-names, equality and hash functions
for external type-constructors (which necessarily cannot participate
in hash-consing) and the type-signatures of memo-izers we wish
generated.  The rewriter generates efficient hash-constructors and
hash/equality-functions: consult the paper for details.
</p>

<p>
Here's the actual code:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #483d8b; background-color: #ebebeb;">[%%import</span>: <span style="color: #228b22;">Sexp.</span>sexp<span style="color: #483d8b; background-color: #ebebeb;">]</span>
<span style="color: #483d8b;">[@@deriving hashcons { hashconsed_module_name = HC</span>
<span style="color: #483d8b;">                     ; normal_module_name = OK</span>
<span style="color: #483d8b;">                     ; external_types = {</span>
<span style="color: #483d8b;">                         Ploc.vala = {</span>
<span style="color: #483d8b;">                           preeq = (fun f x y -&gt; match (x,y) with</span>
<span style="color: #483d8b;">                               (Ploc.VaAnt s1, Ploc.VaAnt s2) -&gt; s1=s2</span>
<span style="color: #483d8b;">                             | (Ploc.VaVal v1, Ploc.VaVal v2) -&gt; f v1 v2</span>
<span style="color: #483d8b;">                             )</span>
<span style="color: #483d8b;">                         ; prehash = (fun f x -&gt; match x with</span>
<span style="color: #483d8b;">                             Ploc.VaAnt s -&gt; Hashtbl.hash s</span>
<span style="color: #483d8b;">                           | Ploc.VaVal v -&gt; f v</span>
<span style="color: #483d8b;">                           )</span>
<span style="color: #483d8b;">                         }</span>
<span style="color: #483d8b;">                       }</span>
<span style="color: #483d8b;">                     ; pertype_customization = {</span>
<span style="color: #483d8b;">                         sexp = {</span>
<span style="color: #483d8b;">                           hashcons_constructor = sexp</span>
<span style="color: #483d8b;">                         }</span>
<span style="color: #483d8b;">                       }</span>
<span style="color: #483d8b;">                     }]</span>
</pre>
</div>

<p>
The resulting OCaml module will contain two new modules: <code>OK</code> (which
contains a copy of the original AST) and <code>HC</code> (which contains the
hashconsed AST, as well as functions for hash-consing, memoizing,
etc).  The hashconsed AST type is as described in the previous
section.
</p>
</div>
</li>

<li><a id="org7d27b75"></a>Generate functions back-and-forth between "normal" and "hashconsed" versions of the AST type.<br />
<div class="outline-text-5" id="text-org7d27b75">
<p>
To generate functions back-and-forth between the two versions of the
AST type, we use the <code>pa_ppx_migrate</code> PPX rewriter. Here is the input
for generating the function from the "normal" (<code>OK</code>) to the
"hashconsed" (<code>HC</code>) AST.  The reverse direction isn't much different.
Notice that we don't actually write any migration code, except for
external types (<code>vala</code>).  In much-more-complicated examples, the
succinctness of this method over the actual code can be quite
significant.  It has been applied to the 10 versions of the OCaml AST
(to generate something quasi-equivalent to <code>ocaml-migrate-parsetree</code>,
and the succinctness gains there are significant.
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #483d8b; background-color: #ebebeb;">[%%import</span>: <span style="color: #228b22;">Sexp_hashcons.OK.</span>sexp<span style="color: #483d8b; background-color: #ebebeb;">]</span>
<span style="color: #483d8b;">[@@deriving migrate</span>
<span style="color: #483d8b;">    { dispatch_type = dispatch_table_t</span>
<span style="color: #483d8b;">    ; dispatch_table_constructor = make_dt</span>
<span style="color: #483d8b;">    ; dispatchers = {</span>
<span style="color: #483d8b;">        migrate_vala = {</span>
<span style="color: #483d8b;">          srctype = [%typ: 'a Ploc.vala]</span>
<span style="color: #483d8b;">        ; dsttype = [%typ: 'b Ploc.vala]</span>
<span style="color: #483d8b;">        ; subs = [ ([%typ: 'a], [%typ: 'b]) ]</span>
<span style="color: #483d8b;">        ; code = _migrate_vala</span>
<span style="color: #483d8b;">        }</span>
<span style="color: #483d8b;">      ; migrate_sexp_node = {</span>
<span style="color: #483d8b;">          srctype = [%typ: sexp_node]</span>
<span style="color: #483d8b;">        ; dsttype = [%typ: Sexp_hashcons.HC.sexp_node]</span>
<span style="color: #483d8b;">        }</span>
<span style="color: #483d8b;">      ; migrate_sexp = {</span>
<span style="color: #483d8b;">          srctype = [%typ: sexp]</span>
<span style="color: #483d8b;">        ; dsttype = [%typ: Sexp_hashcons.HC.sexp]</span>
<span style="color: #483d8b;">        ; code = (fun __dt__ x -&gt;</span>
<span style="color: #483d8b;">            Sexp_hashcons.HC.sexp (__dt__.migrate_sexp_node __dt__ x)</span>
<span style="color: #483d8b;">          )</span>
<span style="color: #483d8b;">        }</span>
<span style="color: #483d8b;">      }</span>
<span style="color: #483d8b;">    }</span>
<span style="color: #483d8b;">]</span>
</pre>
</div>
</div>
</li>

<li><a id="orgba46653"></a>4. Generate functions to map (parsed) values to OCaml AST expressions/patterns<br />
<div class="outline-text-5" id="text-orgba46653">
<p>
We use the <code>pa_ppx_q_ast</code> PPX rewriter, and invoke it twice: once with
the "normal" AST type (<code>Sexp.sexp</code>) and once with the hashconsed type
(<code>Sexp_hashcons.HC.sexp</code>).  The two quotation-expanders are named,
respectively, "sexp" and "hcsexp" (the names are chosen only for this
presentation and are not significant).
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Regular</span> = <span style="color: #000000; font-weight: bold;">struct</span>
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">sexp</span> = <span style="color: #483d8b; background-color: #ebebeb;">[%import</span>: <span style="color: #228b22;">Sexp.</span>sexp<span style="color: #483d8b; background-color: #ebebeb;">]</span>
<span style="color: #483d8b;">[@@deriving q_ast { data_source_module = Sexp }]</span>

<span style="color: #228b22;">Quotation.</span>add <span style="color: #8b2252;">"sexp"</span>
  (apply_entry <span style="color: #228b22;">Pa_sexp.</span>sexp_eoi <span style="color: #228b22;">E.</span>sexp <span style="color: #228b22;">P.</span>sexp)
<span style="color: #000000; font-weight: bold;">end</span>

<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Hashcons</span> = <span style="color: #000000; font-weight: bold;">struct</span>

<span style="color: #483d8b; background-color: #ebebeb;">[%%import</span>: <span style="color: #228b22;">Sexp_hashcons.HC.</span>sexp<span style="color: #483d8b; background-color: #ebebeb;">]</span>
<span style="color: #483d8b;">[@@deriving q_ast {</span>
<span style="color: #483d8b;">    data_source_module = Sexp_hashcons.HC</span>
<span style="color: #483d8b;">  ; quotation_source_module = Sexp_migrate.FromHC</span>
<span style="color: #483d8b;">  ; hashconsed = true</span>
<span style="color: #483d8b;">  }]</span>

<span style="color: #228b22;">Quotation.</span>add <span style="color: #8b2252;">"hcsexp"</span>
  (apply_entry <span style="color: #228b22;">Pa_sexp.</span>sexp_hashcons_eoi <span style="color: #228b22;">E.</span>sexp <span style="color: #228b22;">P.</span>sexp)
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>
</div>
</li>

<li><a id="org3d40397"></a>Putting it all together<br />
<div class="outline-text-5" id="text-org3d40397">
<p>
So: we start with an AST type and a parser, to which antiquotation
markers have been added.  We generate a hashconsed version of the AST
type, and functions back-and-forth to the "normal" version of the
type.  Since we have a parser for the "normal" version, we now have a
parser for the "hashconsed" version.
</p>

<p>
The fancy bit is that Camlp5 has built-in machinery to map values of
types in the OCaml AST of Camlp5 (which is a different recursive type,
but more-or-less equivalent to the official OCaml AST) to expressions
and patterns that correspond to those values.  So the actual AST
<b>value</b> corresponding to <code>x + 1</code> can be mapped to either an expression
(that when evaluated, produces that value) or a pattern (that matches
that value).  But since our AST type contains antiquotation markers,
the AST value corresponding to <code>$x$ + 1</code> can <b>also</b> be mapped to an
expression/pattern, only this time, with OCaml variable <code>x</code> as the
first argument to <code>(+)</code>.
</p>

<p>
The <code>pa_ppx_q_ast</code> PPX rewriter generalizes this and makes it possible
to apply to any AST type (and also to apply to the OCaml AST type in
Camlp5, so nothing has been lost).
</p>
</div>
</li>

<li><a id="org28e54b0"></a>Using the quotations<br />
<div class="outline-text-5" id="text-org28e54b0">
<p>
And finally, we can use those quotations:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">atoms</span> = <span style="color: #a020f0;">function</span>
    &lt;:sexp&lt; () &gt;&gt; -&gt; <span style="color: #000000; background-color: #ffffff;">[]</span>
  | &lt;:sexp&lt; <span style="color: #a52a2a;">$</span>atom:a<span style="color: #a52a2a;">$</span> &gt;&gt; -&gt; [a]
  | &lt;:sexp&lt; ( () . <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">cdr$ </span>) &gt;&gt; -&gt; atoms cdr
  | &lt;:sexp&lt; ( <span style="color: #a52a2a;">$</span>atom:a<span style="color: #a52a2a;">$</span> . <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">cdr$ </span>) &gt;&gt; -&gt; a<span style="color: #000000; background-color: #ffffff;">::</span>(atoms cdr)
  | &lt;:sexp&lt; ( ( <span style="color: #a52a2a;">$</span>exp:caar<span style="color: #a52a2a;">$</span> . <span style="color: #a52a2a;">$</span>exp:cdar<span style="color: #a52a2a;">$</span> ) . <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">cdr$ </span>) &gt;&gt; -&gt;
    atoms &lt;:sexp&lt; ( <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">caar$ . ( $exp:cdar$ . $exp:cdr$ ) </span>) &gt;&gt;

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">atoms</span> = <span style="color: #a020f0;">function</span>
    &lt;:hcsexp&lt; () &gt;&gt; -&gt; <span style="color: #000000; background-color: #ffffff;">[]</span>
  | &lt;:hcsexp&lt; <span style="color: #a52a2a;">$</span>atom:a<span style="color: #a52a2a;">$</span> &gt;&gt; -&gt; [a]
  | &lt;:hcsexp&lt; ( () . <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">cdr$ </span>) &gt;&gt; -&gt; atoms cdr
  | &lt;:hcsexp&lt; ( <span style="color: #a52a2a;">$</span>atom:a<span style="color: #a52a2a;">$</span> . <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">cdr$ </span>) &gt;&gt; -&gt; a<span style="color: #000000; background-color: #ffffff;">::</span>(atoms cdr)
  | &lt;:hcsexp&lt; ( ( <span style="color: #a52a2a;">$</span>exp:caar<span style="color: #a52a2a;">$</span> . <span style="color: #a52a2a;">$</span>exp:cdar<span style="color: #a52a2a;">$</span> ) . <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">cdr$ </span>) &gt;&gt; -&gt;
    atoms &lt;:hcsexp&lt; ( <span style="color: #a52a2a;">$</span>exp:<span style="color: #228b22;">caar$ . ( $exp:cdar$ . $exp:cdr$ ) </span>) &gt;&gt;
</pre>
</div>
</div>
</li>
</ul>
</div>

<div id="outline-container-orgd38cd74" class="outline-4">
<h4 id="orgd38cd74">Discussion</h4>
<div class="outline-text-4" id="text-orgd38cd74">
<p>
I've also applied this same methodology to the entire OCaml AST in
Camlp5 (for which there is a parser, as part of Camlp5) and verified
that the quotations thus generated pass the same tests as the
hand-implemented quotations provided as part of Camlp5.
</p>

<p>
The quotations of Camlp5 are substantial, and cover almost all of the
OCaml language.  I believe that this means it is possible to both
provide full hash-consing support for a very complex AST type, and
full quotation support both for the AST type, and for its
automatically-generated hashconsed variant.
</p>
</div>
</div>

<div id="outline-container-org302333b" class="outline-4">
<h4 id="org302333b">Appendix A: Parameter-parsing for PPX Rewriters</h4>
<div class="outline-text-4" id="text-org302333b">
<p>
I've shown three different PPX rewriters (<code>migrate</code>, <code>hashcons</code>, and
<code>q_ast</code>) and in some of their invocations, there are nontrivial OCaml
expressions to supply as options.  Writing the code that converts
these options (OCaml expressions) into values of meaningful types (for
the rewriter code) is unutterably boring, time-consuming, and error-prone: it is
effectively a <b>demarshalling</b> problem.  So I wrote a PPX rewriter,
that automates this task, and in fact that is what is used to generate
the demarshallers used in these PPX rewriters.  Here is an example:
the <code>params</code> PPX rewriter as used by <code>pa_ppx_migrate</code> to generate
its options demarshaller:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">tyarg_t</span> =
  { srctype : ctyp;
    dsttype : ctyp;
    raw_dstmodule : longid option
      <span style="color: #483d8b;">[@name dstmodule]</span>;
    dstmodule : longid option
      <span style="color: #483d8b;">[@computed longid_of_dstmodule dsttype raw_dstmodule]</span>;
    inherit_code : expr option;
    code : expr option;
    custom_branches_code : expr option;
    custom_branches : (lident, case_branch) alist
      <span style="color: #483d8b;">[@computed extract_case_branches custom_branches_code]</span>;
    custom_fields_code : (lident, expr) alist <span style="color: #483d8b;">[@default []]</span>;
    skip_fields : lident list <span style="color: #483d8b;">[@default []]</span>;
    subs : (ctyp * ctyp) list <span style="color: #483d8b;">[@default []]</span>;
    type_vars : string list
      <span style="color: #483d8b;">[@computed compute_type_vars srctype dsttype subs]</span>;
    subs_types : ctyp list
      <span style="color: #483d8b;">[@computed compute_subs_types loc subs]</span>
}
<span style="color: #483d8b;">[@@deriving params]</span>

<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">default_dispatcher_t</span> =
  { srcmod : longid;
    dstmod : longid;
    types : lident list;
    inherit_code : (lident, expr) alist<span style="color: #483d8b;">[@default []]</span>
  }
<span style="color: #483d8b;">[@@deriving params]</span>

<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">t</span> =
  { optional : bool
  ; plugin_name : string
  ; inherit_type : ctyp option;
    dispatch_type_name : lident<span style="color: #483d8b;">[@name dispatch_type]</span>;
    dispatch_table_constructor : lident;
    declared_dispatchers : (lident, <span style="color: #228b22;">Dispatch1.</span>tyarg_t) alist
      <span style="color: #483d8b;">[@default []]</span> <span style="color: #483d8b;">[@name dispatchers]</span>;
    default_dispatchers : default_dispatcher_t list<span style="color: #483d8b;">[@default []]</span>;
    dispatchers : (lident, <span style="color: #228b22;">Dispatch1.</span>tyarg_t) alist
      <span style="color: #483d8b;">[@computed compute_dispatchers loc type_decls declared_dispatchers default_dispatchers]</span>;
    type_decls : (string * <span style="color: #228b22;">MLast.</span>type_decl) list
      <span style="color: #483d8b;">[@computed type_decls]</span>;
    pretty_rewrites : (string * <span style="color: #228b22;">Prettify.</span>t) list
      <span style="color: #483d8b;">[@computed Prettify.mk_from_type_decls type_decls]</span> }
<span style="color: #483d8b;">[@@deriving params {formal_args = {t = [type_decls]}}]</span>
</pre>
</div>

<p>
This generates a function <code>params : (string * MLast.type_decl) list -&gt;
MLast.expr -&gt; t</code> that performs the entire demarshalling task.  At a
couple of points, we supply functions to handle custom demarshalling
operations, but the vast majority of the code (and work) is handled
automatically.  This is <b>liberating</b>: it means that there is no cost
to being precise in describing the data one needs as input, and no need
to "encode" arguments into easy-to-parse form.  A good comparison is
with the "@with" syntax of the <code>ppx_import</code> PPX rewriter, where it's
clear that they're shoe-horning types into expression syntax, for want
of a nicer syntax that is still easily to manipulate.
</p>
</div>
</div>

<div id="outline-container-org4452d3b" class="outline-4">
<h4 id="org4452d3b">Appendix B: Types with without <code>vala</code></h4>
<div class="outline-text-4" id="text-org4452d3b">
<p>
In the "Motivation" section, I introduced a type of <code>sexp</code>, and then
the hashconsed version of the type.  Neither type had <code>vala</code> markings
in it.  The mechanism described in this post can equally well work to
produce quotation-expanders that work over types without <code>vala</code>.  The
only difficulty, is that the <b>parser</b> still needs to be defined over a
version of the type with <code>vala</code>, because it will be used to parse
quotations (which must necessarily contain antiquotations).  But
everything else works, and in
<code>camlp5/pa_ppx_q_ast/tests/{sexp_example,eg_sexp_example}</code> you will
find the definition and use of "sexpnovala", a quotation expander for
the first <code>sexp</code> type we defined in this post.  I didn't bother
building the quotation expander for "hcsexpnovala", but it's a
straightforward exercise.
</p>

<p>
In short, the choice of whether your AST type needs to have <code>vala</code>
markings in it, is independent of hash-consing.  You only need to
supply a version of your AST type with <code>vala</code>, along with a parser,
for the quotation machinery.
</p>
</div>
</div>

<div id="outline-container-org6dcbe77" class="outline-4">
<h4 id="org6dcbe77">Appendix C: Is <code>vala</code> Necessary?</h4>
<div class="outline-text-4" id="text-org6dcbe77">
<p>
Consider that <code>sexp</code> type
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">sexp</span> =
    <span style="color: #000000; background-color: #ffffff;">Atom</span> <span style="color: #a020f0;">of</span> string
  | <span style="color: #000000; background-color: #ffffff;">Cons</span> <span style="color: #a020f0;">of</span> sexp * sexp
  | Nil
</pre>
</div>

<p>
If we want to provide a <code>ppx_metaquot</code>-like facility for this type,
perhaps we can overload the meaning of the strings in atoms.  So the
s-expression
</p>

<div class="org-src-container">
<pre class="src src-ocaml">( _A . foo )
</pre>
</div>

<p>
that expands to
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; background-color: #ffffff;">Cons</span>(<span style="color: #000000; background-color: #ffffff;">Atom</span> <span style="color: #8b2252;">"_A"</span>, <span style="color: #000000; background-color: #ffffff;">Atom</span> <span style="color: #8b2252;">"foo"</span>)
</pre>
</div>

<p>
could mean an s-expression with a single meta-variable, <code>_A</code>.  But
this meta-variable is necessarily a variable that can only denote an
s-expression, and not a string.  More generally, in an AST type if
metavariables are merely overloaded variables, anyplace that a
variable cannot appear, cannot be subject to meta-variable-based
pattern-matching/substitution.  So it's not possible to match on the
list of types or expressions in a tuple type/expression, nor the list
of branches in a match-with.  And on and on.  This is why the version
of the <code>sexp</code> type with antiquotation markers
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">sexp</span> =
    <span style="color: #000000; background-color: #ffffff;">Atom</span> <span style="color: #a020f0;">of</span> (string vala)
  | <span style="color: #000000; background-color: #ffffff;">Cons</span> <span style="color: #a020f0;">of</span> (sexp vala) * (sexp vala)
  | Nil
</pre>
</div>

<p>
includes <code>Atom of (string vala)</code>.  This allows us to write a pattern
with a metavariable that matches an s-expression, e.g.
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; background-color: #ffffff;">Cons</span> (<span style="color: #000000; background-color: #ffffff;">VaVal</span> x, <span style="color: #000000; background-color: #ffffff;">VaVal</span> (<span style="color: #000000; background-color: #ffffff;">Atom</span> (<span style="color: #000000; background-color: #ffffff;">VaVal</span> <span style="color: #8b2252;">"foo"</span>)))
</pre>
</div>

<p>
(in quotation syntax, <code>&lt;:sexp&lt; ( $exp:x$ . bar ) &gt;&gt;</code>) or a
metavariable that matches the <code>string</code> in an <code>Atom</code>,
e.g.
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; background-color: #ffffff;">Cons</span>
  (<span style="color: #000000; background-color: #ffffff;">VaVal</span> (<span style="color: #000000; background-color: #ffffff;">Atom</span> (<span style="color: #000000; background-color: #ffffff;">VaVal</span> x)),
   <span style="color: #000000; background-color: #ffffff;">VaVal</span> (<span style="color: #000000; background-color: #ffffff;">Atom</span> (<span style="color: #000000; background-color: #ffffff;">VaVal</span> <span style="color: #8b2252;">"foo"</span>)))
</pre>
</div>

<p>
And this is a general issue in all (meta-)quotation support, not
merely for the OCaml AST.  If we want high-quality quotation support
for our data-types, we need to build high-quality suppot for
antiquotations.
</p>
</div>
</div>
</div>
</div>




<div id="outline-container-orgaca6f48" class="outline-2">
<h2 id="8">Official shutdown date of forge.ocamlcore.org is 2020-10-18</h2>
<div class="outline-text-2" id="text-8">
<p>
Archive: <a href="https://discuss.ocaml.org/t/official-shutdown-date-of-forge-ocamlcore-org-is-2020-10-18/6589/1">https://discuss.ocaml.org/t/official-shutdown-date-of-forge-ocamlcore-org-is-2020-10-18/6589/1</a>
</p>
</div>

<div id="outline-container-org9bdea3e" class="outline-3">
<h3 id="org9bdea3e">Sylvain Le Gall announced</h3>
<div class="outline-text-3" id="text-org9bdea3e">
<p>
The website forge.ocamlcore.org will be shut down on 2020-10-18 12:00 UTC+2. I took the last official
snapshot of the website 1 month ago. I have prepared dumps for all of the projects and can make them
available to the admin of the projects. The dumps contain all the changes since the last snapshot
(2020-09-15). Any changes in between the last snapshot and the shutdown, will be discarded.
</p>

<p>
This is the final step of the official announcement deprecation from 2017[1]. I have ensured that the
activity of the website has dropped to almost zero since then. Most of the projects are now hosted
elsewhere. The search engine data indicate that the traffic has dropped significantly enough since I
have asked to de-index the whole website.
</p>

<p>
The design of the static website is inspired by the one for <a href="http://luaforge.net">http://luaforge.net</a>
</p>

<p>
[1]: <a href="https://forge.ocamlcore.org/forum/forum.php?forum_id=958">https://forge.ocamlcore.org/forum/forum.php?forum_id=958</a>
</p>
</div>

<div id="outline-container-orga55f2c1" class="outline-4">
<h4 id="orga55f2c1">What are the actions members can do now?</h4>
<div class="outline-text-4" id="text-orga55f2c1">
<p>
WARNING: Some web browsers like Chrome will claim that the temporary site name is misleading and too
close to forge.ocamlcore.org and it is a potential phishing attempt, but this should be safe.
</p>

<p>
Here are the actions you can take now:
</p>

<ul class="org-ul">
<li>Project admins can get back the dump of project data (see the <a href="https://forge-ocamlcore-org.netlify.app/faq#get_forge_dump">FAQ</a>)</li>

<li>Project admins can send PR to indicate the new project homepage (see the <a href="https://forge-ocamlcore-org.netlify.app/faq#projects_page">FAQ</a>)</li>

<li>Members can send PR to indicate their new homepage (see the the <a href="https://forge-ocamlcore-org.netlify.app/faq#users_page">FAQ</a>)</li>
</ul>

<p>
The whole process is still a bit undefined, because I need proof that the people sending PR were admins
of the project. I still need to figure out a good way to get these proofs, so I will experiment a bit
at the beginning (see the <a href="https://forge-ocamlcore-org.netlify.app/faq#get_forge_dump">FAQ</a> for the
current state).
</p>

<p>
You can already check what the website will look like on <a href="https://forge-ocamlcore-org.netlify.app/">https://forge-ocamlcore-org.netlify.app/</a>
</p>
</div>
</div>

<div id="outline-container-org27da9e3" class="outline-4">
<h4 id="org27da9e3">What will happen next?</h4>
<div class="outline-text-4" id="text-org27da9e3">
<p>
<span class="underline">2020-10-11 -&gt; 2020-10-18:</span>
</p>

<ul class="org-ul">
<li>Members can still browse the website and recover what will not be part of the project dump.</li>
</ul>

<p>
Any changes to the website made during this time, will be discarded.
</p>

<p>
<span class="underline">2020-10-18:</span>
</p>

<ul class="org-ul">
<li>I will archive a whole copy of the website VM (encrypted)</li>

<li><a href="https://forge.ocamlcore.org">https://forge.ocamlcore.org</a> will become a static website only containing “anonymous” data (see <a href="https://forge-ocamlcore-org.netlify.app/%20">prototype</a>)</li>

<li>All file downloads will use <a href="https://downloads.ocamlcore.org">https://downloads.ocamlcore.org</a> (this is already the case)</li>

<li>All mailing lists will be shut down</li>

<li>Source control will not be accessible anymore (this is already the case)</li>

<li>All domains *.forge.ocamlcore.org will point to the matching project page or to the FAQ.</li>
</ul>

<p>
<span class="underline">2021-04-18:</span>
</p>

<ul class="org-ul">
<li>Last time for admins to get back the dump of project data (see the FAQ)</li>

<li>Last time for members and admins to update their page on the static website</li>

<li>I will destroy the copy of the website VM</li>
</ul>

<p>
Past this point, I will still have the dumps of the project data and will still accept PR for the
Github repository, but this will be a “best effort” SLO.
</p>
</div>
</div>
</div>
</div>




<div id="outline-container-org162d084" class="outline-2">
<h2 id="org162d084">Old CWN</h2>
<div class="outline-text-2" id="text-org162d084">
<p>
If you happen to miss a CWN, you can <a href="mailto:alan.schmitt@polytechnique.org">send me a message</a> and I'll mail it to you, or go take a look at <a href="http://alan.petitepomme.net/cwn/">the archive</a> or the <a href="http://alan.petitepomme.net/cwn/cwn.rss">RSS feed of the archives</a>.
</p>

<p>
If you also wish to receive it every week by mail, you may subscribe <a href="http://lists.idyll.org/listinfo/caml-news-weekly/">online</a>.
</p>

<div class="authorname">
<p>
<a href="http://alan.petitepomme.net/">Alan Schmitt</a>
</p>

</div>
</div>
</div>
</div>
</body>
</html>
