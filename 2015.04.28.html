<?xml version="1.0" encoding="utf-8"?>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>OCaml Weekly News</title>
  </head>
  <body>
    <a href="2015.04.21.html">Previous week</a> <a href="index.html">Up</a> <a href="2015.05.05.html">Next week</a><p>Hello</p><p>Here is the latest OCaml Weekly News, for the week of April 21 to 28, 2015.</p><ol><li><a href="#1">Suggested way to determine platform specific capabilities in build system?</a></li><li><a href="#2">systemd/journal bindings</a></li><li><a href="#3">New software written in OCaml</a></li><li><a href="#4">gen_js_api: generating Javascript bindings from OCaml interfaces</a></li><li><a href="#5">js_of_ocaml with node</a></li><li><a href="#6">Other OCaml News</a></li></ol><a name="1" /><hr /><h3>Suggested way to determine platform specific capabilities in build system?</h3><p>Archive: <a href="https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00105.html">https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00105.html</a></p><i>Continuing the thread from last week, Richard Jones said:</i><br /><pre>
&gt; What is the current suggested way to determine what, roughly, autoconf
&gt; would do for you?  I have some platform specific functionality to be
&gt; included (or excluded) depending on the OS.

Is there a reason not to use autoconf?  I use it all the time with
OCaml projects, eg:

<a href="https://github.com/libguestfs/libguestfs">https://github.com/libguestfs/libguestfs</a>
<a href="https://github.com/libguestfs/supermin">https://github.com/libguestfs/supermin</a>

and a random more recent example:

<a href="http://git.annexia.org/?p=mclu.git;a=tree">http://git.annexia.org/?p=mclu.git;a=tree</a>

There are ocaml.m4 macros on ocamlforge.
      </pre><a name="2" /><hr /><h3>systemd/journal bindings</h3><p>Archive: <a href="https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00112.html">https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00112.html</a></p><i>Jürgen Hötzel announced:</i><br /><pre>
I implemented some basics systemd bindings (just journal functions at the
moment):

<a href="https://github.com/juergenhoetzel/ocaml-systemd">https://github.com/juergenhoetzel/ocaml-systemd</a>

Any feedback is appreciated.
      </pre><a name="3" /><hr /><h3>New software written in OCaml</h3><p>Archive: <a href="https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00125.html">https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00125.html</a></p><i>Leo Wzukw announced:</i><br /><pre>
I developed since about a year a tools named OcLaunch. It allow to spread
launch of program across session, each time a terminal (or anything else) is
called.
For example, you may want to launch a client chat and several TODO list, and
then verify update. If add all to your .bashrc, the output will be displayed
every time it is sourced, i. e. each time you open a terminal. What a mess!
With OcLaunch, these commands are launched one at time. So

* You open your first terminal: the client chat is launched 
* You open the second one: a TODO list is displayed 
* ... and so on 

An other advantage is that your reminder are spread across your session, which
remind you important task several times and may limit procrastination!

Official website is <a href="http://oclaunch.tuxfamily.org/home.html">http://oclaunch.tuxfamily.org/home.html</a>. You can find a
demo video if the purpose of OcLaunch is not clear and several resources.

Email me if you need some help or to give feedback.

Leo

PS: People reading French may be interested by this page :
<a href="http://linuxfr.org/news/oclaunch-launch-automagically">http://linuxfr.org/news/oclaunch-launch-automagically</a> 
      </pre><a name="4" /><hr /><h3>gen_js_api: generating Javascript bindings from OCaml interfaces</h3><p>Archive: <a href="https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00131.html">https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00131.html</a></p><i>Alain Frisch announced:</i><br /><pre>
LexiFi is currently experimenting with the js_of_ocaml compiler in order to
create some browser-side applications in OCaml. In this context, we have
started a new project called gen_js_api which aims at simplifying the creation
of bindings to Javascript libraries.

The approach is quite different from js_of_ocaml's native FFI (which relies on
language extensions). In gen_js_api, authors of bindings define the expected
OCaml interface, annotated with light attributes to define the actual mapping
to Javascript; and client of generated bindings work with native OCaml types,
without requiring any language extension, nor any knowledge of how js_of_ocaml
represents OCaml values in Javascript.

gen_js_api has reached a state where actual bindings can be written, and it is
reasonably well documented. It is now a good time to look at the project if
you're interested in this topic. Of course, feel free to comment on the
project or contribute to it.

Project page:

  <a href="https://github.com/alainfrisch/gen_js_api">https://github.com/alainfrisch/gen_js_api</a>
      </pre><a name="5" /><hr /><h3>js_of_ocaml with node</h3><p>Archive: <a href="https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00132.html">https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00132.html</a></p><i>Helmut Brandl asked:</i><br /><pre>
I am currently writing a software package in ocaml and I want to be able to
compile it from ocaml to javascript to be able to run it under nodejs. I have
found js_of_ocaml which seems to do a rather good job in compiling from
bytecode to javascript.

I achieved the compilation to javascript which can run under nodejs as long as
I don't use anything from the unix library. Unfortunately I need two functions
from the unix library: 1. Get the last modification time of a file. 2. Create
a directory. I cannot find anything equivalent in the standard library.

I tried to find some hints in the js_of_ocaml documentation but I haven't
succeeded because to documentation is hard to read.

Can anybody give me some hints on how to get these two functions in a way that
js_of_ocaml does the correct compilation?
      </pre><i>Daniel Bünzli suggested:</i><br /><pre>
If you are getting unknown primitive errors at link time then you can simply
try to implement them yourself using node's filesystem APIs see:

<a href="http://ocsigen.org/js_of_ocaml/2.5/manual/linker">http://ocsigen.org/js_of_ocaml/2.5/manual/linker</a>

If you are not concerned about using Unix directly (because node.js is your
only target) and simply need these functions you can bind the corresponding
node API functions directly:

<a href="http://ocsigen.org/js_of_ocaml/2.5/manual/bindings">http://ocsigen.org/js_of_ocaml/2.5/manual/bindings</a>
      </pre><i>Alain Frisch also suggested:</i><br /><pre>
You need to define bindings to node.js' "fs" API:

<a href="https://nodejs.org/api/fs.html">https://nodejs.org/api/fs.html</a>

It should be possible to implement a subset of the Unix module through this
API, or just to expose the few functions you would need.

For instance, with the gen_js_api I announced earlier today, binding the
synchronous mkdir function would look like:

 val mkdir: string -&gt; int -&gt; unit
   [@@js.global "fs.mkdirAsync"]
      </pre><i>Daniel Bünzli then said and Alain Frisch replied:</i><br /><pre>
&gt; That should be "fs.mkdirSync".

Indeed!

&gt; Just curious, how would the binding to the async fs.mkdir look like ?

Something like:

val mkdir_async: string -&gt; int -&gt; (js_exn option -&gt; unit) -&gt; unit
  [@@js.global "fs.mkdir"]

assuming some predefined bindings for js_exn.  (One could also decide to bind
JS exception to OCaml's exn type, but the gain is not clear.)

There are other possible variations, such as making the mode optional:

val mkdir_async:
    string -&gt;
    ?mode:(int[@js.default 0o777]) -&gt;
    (js_exn option -&gt; unit) -&gt;
    unit
  [@@js.global "fs.mkdir"]


Here js.default forces the default value for the optional mode argument.
Without it, a missing value will send an `undefined` as the second argument (I
don't know if fs.mkdir would be happy with it).  This is currently not
supported, but one could also extend the tool to allow:

val mkdir_async:
    string -&gt;
    ?mode:(int[@js.drop_if_missing]) -&gt;
    (js_exn option -&gt; unit) -&gt; unit
  [@@js.global "fs.mkdir"]

so that the second argument is dropped in the JS call if not provided (but
I don't see how to support that for OCaml callbacks in full generality, since
the function needs to check the type of arguments to decide how to interpret
them).
      </pre><i>Alain Frisch later added:</i><br /><pre>
&gt; Here js.default forces the default value for the optional mode argument.
&gt;   Without it, a missing value will send an `undefined` as the second
&gt; argument (I don't know if fs.mkdir would be happy with it).

Just to clarify:  the issue here is that node.js documents the function as:

 fs.mkdir(path[, mode], callback)


and its implementation is more liberal:

=================
function modeNum(m, def) {
  if (util.isNumber(m))
    return m;
  if (util.isString(m))
    return parseInt(m, 8);
  if (def)
    return modeNum(def);
  return undefined;
}

fs.mkdir = function(path, mode, callback) {
  if (util.isFunction(mode)) callback = mode;
  ...
      modeNum(mode, 511 /*=0777*/)
  ...
};
=================

(welcome to Javascript wonderful calling conventions!)


So both conventions are supported to omit the mode argument:

  fs.mkdir(path, undefined, callback)
  fs.mkdir(path, callback)


(one could actually pass anything as the second argument as long as it is not
a number, not a string and not a function).

So it is ok to bind it simply as:

val mkdir_async: string -&gt; ?mode:int -&gt; (js_exn option -&gt; unit) -&gt;  unit
  [@@js.global "fs.mkdir"]
      </pre><a name="6" /><hr /><h3>Other OCaml News</h3><i>From the ocamlcore planet blog:</i><br /><pre>
Thanks to Alp Mestan, we now include in the OCaml Weekly News the links to the
recent posts from the ocamlcore planet blog at <a href="http://planet.ocaml.org/">http://planet.ocaml.org/</a>.

CueKeeper: Gitting Things Done in the browser:
  <a href="http://roscidus.com/blog/blog/2015/04/28/cuekeeper-gitting-things-done-in-the-browser/">http://roscidus.com/blog/blog/2015/04/28/cuekeeper-gitting-things-done-in-the-browser/</a>

Generating Javascript bindings from OCaml interfaces:
  <a href="http://www.lexifi.com/blog/generating-javascript-bindings-ocaml-interfaces">http://www.lexifi.com/blog/generating-javascript-bindings-ocaml-interfaces</a>

Coq 8.5 beta 2 is out!:
  <a href="https://coq.inria.fr/news/125.html">https://coq.inria.fr/news/125.html</a>

Recover the good old C-x C-b (list-buffers) behaviour around Emacs 24.4 and later:
  <a href="http://camlspotter.blogspot.com/2015/04/recover-good-old-c-x-c-b-list-buffers.html">http://camlspotter.blogspot.com/2015/04/recover-good-old-c-x-c-b-list-buffers.html</a>
      </pre><hr /><h3>Old cwn</h3><p>If you happen to miss a CWN, you can <a href="mailto:alan.schmitt@polytechnique.org">send me a message</a> and I'll mail it to you, or go take a look at <a href="http://alan.petitepomme.net/cwn/">the archive</a> or the <a href="http://alan.petitepomme.net/cwn/cwn.rss">RSS feed of the archives</a>.</p><p>If you also wish to receive it every week by mail, you may subscribe <a href="http://lists.idyll.org/listinfo/caml-news-weekly/">online</a>.</p><hr /><p align="right"><i><a href="http://alan.petitepomme.net/">Alan Schmitt</a></i></p><p align="right"><script type="text/javascript">var sc_project=1252199; 
                 var sc_invisible=0; 
                 var sc_partition=11; 
                 var sc_security="e7c40dd3"; 
                 var sc_text=3;</script><script type="text/javascript" src="http://www.statcounter.com/counter/counter_xhtml.js" /><script src="http://www.google-analytics.com/urchin.js" type="text/javascript" /><script type="text/javascript">_uacct = "UA-2289702-1";
								urchinTracker();</script></p></body>
</html>