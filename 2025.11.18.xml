<cwn>
  <cwn_head>
    <cwn_date>2025.11.18</cwn_date>
    <cwn_prev>2025.11.11</cwn_prev>
    <cwn_next>2025.11.25</cwn_next>
    <cwn_date_text>November 11 to 18, 2025</cwn_date_text>
  </cwn_head>
  <cwn_body>
    <cwn_entry>
      <cwn_title>opam 2.5.0~beta1</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ann-opam-2-5-0-beta1/17469/1</cwn_url>
      <cwn_who>Kate announced</cwn_who>
      <cwn_what>
Hi everyone,

We are happy to announce the first beta release of opam 2.5.0.

This version is a beta, we invite users to test it to spot previously unnoticed bugs as we head towards the stable release.

*** Changes

- :red_apple: Allow the macOS sandbox to write in the ~/var/folders/~ and ~/var/db/mds/~ directories as it is required by some of macOS core tools ([#4389](https://github.com/ocaml/opam/issues/4389), [#6460](https://github.com/ocaml/opam/issues/6460))

- Stop ~opam switch create --dry-run~ from creating any directory. *Thanks to @hannes for this contribution.* ([#5918](https://github.com/ocaml/opam/issues/5918))

- :ocean: A couple more changes were made and minor regressions were fixed


:open_book: You can read our [blog post](https://opam.ocaml.org/blog/opam-2-5-0-beta1/) for more information about these changes and more, and for even more details you can take a look at the [release note](https://github.com/ocaml/opam/releases/tag/2.5.0-beta1) or the [changelog](https://github.com/ocaml/opam/blob/2.5.0-beta1/CHANGES).

*** Try it!

The upgrade instructions are unchanged:

For Unix systems
#+begin_example
bash -c "sh &lt;(curl -fsSL https://opam.ocaml.org/install.sh) --version 2.5.0~beta1"
#+end_example
or from PowerShell for Windows systems
#+begin_example
Invoke-Expression "&amp; { $(Invoke-RestMethod https://opam.ocaml.org/install.ps1) } -Version 2.5.0~beta1"
#+end_example
Please report any issues to the [bug-tracker](https://github.com/ocaml/opam/issues).

Happy hacking,
&lt;&gt; &lt;&gt; The opam team &lt;&gt; &lt;&gt; :camel:
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>Announcing the first release of Alice, a radical OCaml build system</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/announcing-the-first-release-of-alice-a-radical-ocaml-build-system/17472/1</cwn_url>
      <cwn_who>Steve Sherratt announced</cwn_who>
      <cwn_what>
I’m pleased to announce the initial release of [Alice](https://github.com/alicecaml/alice), a radical, experimental OCaml build system, package manager, and environment manager for [Windows](https://www.alicecaml.org/porting-alice-to-windows/), macOS, and Linux. Its goal is to allow anyone to program in OCaml with as little friction as possible.

To build your first program with Alice, run:
#+begin_example
$ alice tools install   # Skip this if you already have an OCaml compiler!
$ alice new hello
$ cd hello
$ alice run
 Compiling hello v0.1.0
   Running hello/build/packages/hello-0.1.0/debug/executable/hello

Hello, World!
#+end_example

The UI is heavily inspired by Cargo.

An important distinction between Alice's and Opam's packaging philosophies is that in Alice, _the OCaml compiler and development tools are not packages_. The ~alice tools install~ command will install a pre-compiled ([relocatable!](https://www.youtube.com/watch?v=5JDSUCx-tPw)) OCaml compiler, a compatible ~ocamllsp~, and ~ocamlformat~ user-wide, similar to how ~rustup~ installs the Rust compiler and LSP server. This lets you go from zero to OCaml really fast because you don't have to build the compiler from source. This speedup is particularly noticeable on Windows where building the compiler can take upwards of 10 minutes.

Alice supports building packages with dependencies on other packages, but currently only local packages are supported, and it can only build _Alice_ packages, not Opam packages. See an example [here](https://github.com/alicecaml/alice?tab=readme-ov-file#tutorial). I'll probably add Opam compatibility in the future.

It's still early days and [a lot](https://github.com/alicecaml/alice?tab=readme-ov-file#disclaimers) is missing before Alice could feasibly be used for real projects.

If you want to try it out anyway, install the ~alice~ Opam package, the ~github:alicecaml/alice~ Nix flake, or run the interactive install script:
#+begin_example
curl -fsSL https://alicecaml.org/install.sh | sh
#+end_example
More details about installing Alice are [here](https://www.alicecaml.org/install/).

If you want read more, check out the [blog](https://www.alicecaml.org/blog/).
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>First release of ppx_deriving_jsont</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ann-first-release-of-ppx-deriving-jsont/17478/1</cwn_url>
      <cwn_who>vds announced</cwn_who>
      <cwn_what>
I am happy to announce the first release of [~ppx_deriving_jsont~](https://github.com/voodoos/ppx_deriving_jsont).

As the name implies, it is a tool that automates some of the burden inherent to writing Jsont descriptions. [Jsont](https://erratique.ch/software/jsont) is a fairly novel library for declarative JSON data manipulation, created by @dbuenzli.

This ppx can manage most of the basic types, tuples, variants and records, but still lacks a lot of features and control. It is also quite bad at error reporting. The current roadmap, which highlights existing and missing features can be found in [the project’s readme](https://github.com/voodoos/ppx_deriving_jsont?tab=readme-ov-file#deriving-jsont) along with many examples. I focused on generating readable and reusable code, close to the [cookbook](https://erratique.ch/software/jsont/doc/cookbook.html) illustrations.

Note that Jsont offers much finer control and many more features than what that you can achieve using this crude ppx. Please take some time to read about all of its intricacies:

- In the official [documentation](https://erratique.ch/software/jsont/doc/) and [cookbook](https://erratique.ch/software/jsont/doc/cookbook.html)
- In Daniel’s [introductory post](https://discuss.ocaml.org/t/ann-jsont-0-1-0-declarative-json-data-manipulation-for-ocaml/15702) here on discuss.

When precision and good error handling are required, such as when interacting with external json sources, thoughtfully crafted descriptions should still be considered. But I do believe this ppx to be very useful for bootstrapping, prototyping or when both the encoders and decoders are entirely under the app’s control. I wrote it to that intent and already use it in several personal projects. I hope you will find it useful too! (and not too non-sensical :slightly_smiling_face:)
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>crypt 2.0 - unix crypt function</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ann-crypt-2-0-unix-crypt-function/17485/1</cwn_url>
      <cwn_who>Mikhail announced</cwn_who>
      <cwn_what>
Hi there!

I'm happy to announce the release of a new major version (i.e., 2.0) of the [crypt](https://github.com/vbmithr/ocaml-crypt) library (bindings to the [Unix crypt](https://en.wikipedia.org/wiki/Crypt_(Unix)) function). The previous version, 1.3, was outdated, since the last commit was six years ago. This version does not support correct compilation on various Unix platforms (Linux, FreeBSD, macOS), and uses deprecated tools. However, the new version addresses these issues: it supports Linux, FreeBSD and macOS, uses modern tools, has safe C stubs, provides excellent documentation, and features an idiomatic high-level wrapper.

*** Installation 
by OPAM package manager:
#+begin_example
$ opam install crypt.2.0  
#+end_example

*** Example of usage

#+begin_src ocaml
# #require "crypt";;

# Crypt.crypt ~salt:"GUBv0xjJ" "hello";;
- : string = "GUpsIDCLVu8AY"

# Crypt.crypt ~derivation:Md5 ~salt:"GUBv0xjJ" "hello";;
- : string = "$1$GUBv0xjJ$rQSvX8r6cT7H/NItzzVNQ/"
#+end_src
If you don't provide any salt, a new salt will be generated every time the function is called.
#+begin_src ocaml
# Crypt.crypt "hello";;
- : string = "QwD.wi5nLT/0s"

# Crypt.crypt "hello";;
- : string = "MYM.5hv5Lk2Mg"
#+end_src
But for a deterministic generation, you should use one salt that you can generate using the ~Crypt.Salt~ module or another external module.
#+begin_src ocaml
# let salt = Crypt.Salt.gen_base64 9;;
val salt : string = "dHiPl3q99"

# Crypt.crypt ~salt "hello";;
- : string = "dHDdeFGUWcGyQ"
#+end_src

*** P.S.

Project that uses ~crypt~:
- Recently I wrote [toy implementation of ~login~ utility written in OCaml](https://github.com/dx3mod/tinylogin)
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>Artisanal Coding Is Dead, Long Live Artisanal Coding!</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/artisanal-coding-is-dead-long-live-artisanal-coding/17487/1</cwn_url>
      <cwn_who>Joel Reymont announced</cwn_who>
      <cwn_what>
I wrote [a blog post](https://joel.id/artisanal-coding-is-dead-long-live-artisanal-coding) about adding command history browsing and editing, as well as tab completion, to ~ocamldebug~, without typing a single line of code. I challenge you to review the PR for fun and to try to find holes in it!

I’m going to add DWARF debugging information to OCaml next. I think it’s [almost ready to go](https://x.com/joelreymont/status/1988948903593402437?s=20) but needs double and triple checking. Commits look like this

#+begin_example
Date:   Thu Nov 13 14:55:24 2025 +0200


Add DWARF tests for basic functionality

Add minimal tests to verify DWARF emission works correctly with -g flag.
Tests compile OCaml programs with debugging enabled and verify correct
execution.
#+end_example

and

#+begin_example
Date:   Thu Nov 13 14:54:30 2025 +0200

Implement DWARF v4 debugging support for OCaml

Add complete DWARF version 4 debugging information generation for OCaml
native code. The implementation generates debug info for functions, types,
and line numbers, enabling debugger support for OCaml programs.

Key components:
- Low-level DWARF primitives (tags, attributes, forms, encodings)
- Debug Information Entries (DIE) construction
- Line number program generation
- String table management with offset tracking
- Code address tracking and relocation
- Integration with OCaml compilation pipeline
- Configuration flags to enable/disable DWARF emission

The implementation follows the DWARF 4 specification and generates
valid debug sections (.debug_info, .debug_line, .debug_str, .debug_abbrev)
that can be consumed by standard debuggers like gdb and lldb.
#+end_example
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>Moonpool 0.10, and a blogpost about Moonpool at Imandra</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ann-moonpool-0-10-and-a-blogpost-about-moonpool-at-imandra/17493/1</cwn_url>
      <cwn_who>Simon Cruanes announced</cwn_who>
      <cwn_what>
Good morning,

A couple of news about Moonpool. Moonpool is a concurrency and parallelism library that provides a ~Runner.t~ abstraction, implemented mostly by thread pools, as a way to run lightweight tasks possibly on multiple cores.

First, I just wrote a blog post about [our use of Moonpool](https://docs.imandra.ai/imandrax/blog/2025-11-12-moonpool-in-imandrax/index.html) at Imandra. The post discusses our experience with using Moonpool and some lessons learned over time.

Secondly, Moonpool 0.10 was just released. It contains a few bugfixes, and removes some deprecated modules. It also removes ~moonpool.fib~ (fibers with structured concurrency) as they have turned out, over the years, to be somewhat hard to use properly (they assume the existence of a parent fiber, making code highly context-dependent). Lightweight thread-safe futures (based on Picos') with per-future local-storage are still there and serve mostly the same purpose. The release and change notes can be found [here](https://github.com/c-cube/moonpool/releases/tag/v0.10).
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>libdrm - OCaml bindings for Linux mode setting, etc</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ann-libdrm-ocaml-bindings-for-linux-mode-setting-etc/17497/1</cwn_url>
      <cwn_who>Thomas Leonard announced</cwn_who>
      <cwn_what>
I'm pleased to announce the first release of [libdrm-ocaml](https://github.com/talex5/libdrm-ocaml) (OCaml bindings for the libdrm C library).

libdrm is used by applications such as Wayland compositors to control the physical graphics hardware.

For example, you can use the library to enumerate graphics devices:

#+begin_src ocaml
utop # Drm.Device.list ();;
- : Drm.Device.Info.t list =
[{primary_node = Some "/dev/dri/card0";
  render_node = Some "/dev/dri/renderD128";
  info = PCI {bus = {domain = 0; bus = 1; dev = 0; func = 0};
              dev = {vendor_id = 0x1002;
                     device_id = 0x67ff;
                     subvendor_id = 0x1458;
                     subdevice_id = 0x230b;
                     revision_id = 0xff}}}]

utop # let dev = Unix.openfile "/dev/dri/card0" [O_CLOEXEC; O_RDWR] 0;;

utop # Drm.Device.Version.get dev;;
- : Drm.Device.Version.t =
{version = 3.61.0; name = "amdgpu"; date = "0"; desc = "AMD GPU"}
#+end_src

Here's an excerpt configuring a hardware plane to present a framebuffer on a CRT controller:

#+begin_src ocaml
plane.%{ K.Plane.fb_id } &lt;- Some fb;
(* Source region on frame-buffer: *)
plane.%{ K.Plane.src_x } &lt;- Drm.Ufixed.of_int 0;
plane.%{ K.Plane.src_y } &lt;- Drm.Ufixed.of_int 0;
plane.%{ K.Plane.src_w } &lt;- Drm.Ufixed.of_int (fst size);
plane.%{ K.Plane.src_h } &lt;- Drm.Ufixed.of_int (snd size);
(* Destination region on CRTC: *)
plane.%{ K.Plane.crtc_x } &lt;- 0;
plane.%{ K.Plane.crtc_y } &lt;- 0;
plane.%{ K.Plane.crtc_w } &lt;- fst size;
plane.%{ K.Plane.crtc_h } &lt;- snd size;
#+end_src

For a proper tutorial, see [Linux mode setting, from the comfort of OCaml](https://roscidus.com/blog/blog/2025/11/16/libdrm-ocaml/).
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>New release of visitors</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ann-new-release-of-visitors/17499/1</cwn_url>
      <cwn_who>François Pottier announced</cwn_who>
      <cwn_what>
I am pleased to announce a new release of ~visitors~, a tool that automatically generates visitor classes for algebraic data types.

The new features of this release are as follows:

- ~visitors~ now decorates every generated method with a type annotation. This can help understand the generated code. More importantly, this enables type-directed disambiguation, so ~visitors~ now supports situations where two distinct types have a field or a data constructor by the same name. (Reported by Guillaume Boisseau. Contributed by Sacha Élie-Ayoun.)

- Install a new executable command, ~visitors_preprocess~, to preprocess an OCaml source file and see the result.

- Update ~Makefile.preprocess~ to use ~visitors_preprocess~.

- Require ~ppxlib~ version 0.37.0 or newer.
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>MirageOS on Unikraft</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/mirageos-on-unikraft/16975/2</cwn_url>
      <cwn_who>Continuing this thread, shym announced</cwn_who>
      <cwn_what>
Just a short update to let you know that OCaml/Unikraft 1.1.0 [has been released](https://github.com/ocaml/opam-repository/pull/28750) with support for OCaml 5.4 and Unikraft 0.20.0.

Happy hacking!
      </cwn_what>
    </cwn_entry>
  </cwn_body>
</cwn>
