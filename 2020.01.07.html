<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-01-07 Tue 14:41 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OCaml Weekly News</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style type="text/css">#table-of-contents h2 { display: none } .title { display: none } .authorname { text-align: right }</style>
<style type="text/css">.outline-2 {border-top: 1px solid black;}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">OCaml Weekly News</h1>
<p>
<a href="http://alan.petitepomme.net/cwn/2019.12.31.html">Previous Week</a> <a href="http://alan.petitepomme.net/cwn/index.html">Up</a> <a href="http://alan.petitepomme.net/cwn/2020.01.14.html">Next Week</a>
</p>

<p>
Hello
</p>

<p>
Here is the latest OCaml Weekly News, for the week of December 31, 2019 to January 07, 2020.
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#1">ocaml-lsp preview</a></li>
<li><a href="#2">Mkocaml Release - Project generator</a></li>
<li><a href="#3">Garbage Collection, Side-effects and Purity</a></li>
<li><a href="#4">A Lightweight OCaml Webapp Tutorial (Using Opium, Caqti, and Tyxml)</a></li>
<li><a href="#5">Release of owl-symbolic 0.1.0</a></li>
<li><a href="#6">Static lifetime</a></li>
<li><a href="#orgf226af9">Old CWN</a></li>
</ul>
</div>
</div>


<div id="outline-container-org74b8486" class="outline-2">
<h2 id="1">ocaml-lsp preview</h2>
<div class="outline-text-2" id="text-1">
<p>
Archive: <a href="https://discuss.ocaml.org/t/ann-ocaml-lsp-preview/4876/15">https://discuss.ocaml.org/t/ann-ocaml-lsp-preview/4876/15</a>
</p>
</div>

<div id="outline-container-org0fd5b9c" class="outline-3">
<h3 id="org0fd5b9c">Continuing this thread, Edwin Török said</h3>
<div class="outline-text-3" id="text-org0fd5b9c">
<p>
Here is an example with ALE and Neovim (tested with v0.3.8):
</p>
<ul class="org-ul">
<li>Install the <a href="https://github.com/dense-analysis/ale">Ale</a> plugin. If your Vim has support for packages (Vim 8+ or Neovim) you can simply clone it in the correct subdir, no need for a plugin manager: <code>git clone https://github.com/w0rp/ale.git .vim/pack/my-plugins/start/ale</code></li>
<li>Add this to your .vimrc:</li>
</ul>

<pre class="example">
" only invoke merlin to check for errors when
" exiting insert mode, not on each keystroke.
let g:ale_lint_on_text_changed="never"
let g:ale_lint_on_insert_leave=1

" enable ALE's internal completion if deoplete is not used
let g:ale_completion_enabled=1

" only pop up completion when stopped typing for ~0.5s,
" to avoid distracting when completion is not needed
let g:ale_completion_delay=500

" see ale-completion-completeopt-bug
set completeopt=menu,menuone,preview,noselect,noinsert

if has('packages')
    packloadall

    " This should be part of ALE itself, like ols.vim
    call ale#linter#Define('ocaml',{
                \ 'name':'ocaml-lsp',
                \ 'lsp': 'stdio',
                \ 'executable': 'ocamllsp',
                \ 'command': '%e',
                \ 'project_root': function('ale#handlers#ols#GetProjectRoot')
                \})

    " remap 'gd' like Merlin would
    nmap &lt;silent&gt;&lt;buffer&gt; gd  &lt;Plug&gt;(ale_go_to_definition_in_split)&lt;CR&gt;

    " go back
    nnoremap &lt;silent&gt; &lt;LocalLeader&gt;gb &lt;C-O&gt;

    " show list of file:line:col of references for symbol under cursor
    nmap &lt;silent&gt;&lt;buffer&gt; &lt;LocalLeader&gt;go :ALEFindReferences -relative&lt;CR&gt;

    " Show documentation if available, and type
    nmap &lt;silent&gt;&lt;buffer&gt; &lt;LocalLeader&gt;hh &lt;Plug&gt;(ale_hover)&lt;CR&gt;

    " So I can type ,hh. More convenient than \hh.
    nmap , &lt;LocalLeader&gt;
    vmap , &lt;LocalLeader&gt;
endif
</pre>
</div>
</div>
</div>




<div id="outline-container-org5aad3c6" class="outline-2">
<h2 id="2">Mkocaml Release - Project generator</h2>
<div class="outline-text-2" id="text-2">
<p>
Archive: <a href="https://discuss.ocaml.org/t/mkocaml-release-project-generator/4949/1">https://discuss.ocaml.org/t/mkocaml-release-project-generator/4949/1</a>
</p>
</div>

<div id="outline-container-orgd5eb9be" class="outline-3">
<h3 id="orgd5eb9be">Chris Nevers announced</h3>
<div class="outline-text-3" id="text-orgd5eb9be">
<p>
I recently created a tool to generate OCaml projects. I constantly have difficulties with dune commands and setting up opam files, etc. Mkocaml generates a dune project with inline tests, opam file, git repository, git ignore, and a
Makefile with easy commands. This tool can be of great help to newcomers, allowing them to get up and running faster!
</p>

<p>
<a href="https://github.com/chrisnevers/mkocaml">https://github.com/chrisnevers/mkocaml</a>
</p>
</div>
</div>
</div>




<div id="outline-container-org3c49439" class="outline-2">
<h2 id="3">Garbage Collection, Side-effects and Purity</h2>
<div class="outline-text-2" id="text-3">
<p>
Archive: <a href="https://discuss.ocaml.org/t/garbage-collection-side-effects-and-purity/4737/1">https://discuss.ocaml.org/t/garbage-collection-side-effects-and-purity/4737/1</a>
</p>
</div>

<div id="outline-container-orgdded73b" class="outline-3">
<h3 id="orgdded73b">Gerard asked</h3>
<div class="outline-text-3" id="text-orgdded73b">
<p>
GC = Garbage Collection
</p>

<p>
GC, in a pure program, is a point that's always confused me. I always understood that freeing memory from a program was impure and would create side-effects but it seems it doesn't matter if the program is remove from all consequences of those impure acts and side-effects.
</p>

<p>
Basically, if any memory block has no remaining references in the program, then freeing that block will have no consequences on the running program so its allowed to happen behind the scenes..
</p>

<p>
Is this correct reasoning?
</p>
</div>
</div>


<div id="outline-container-org5825420" class="outline-3">
<h3 id="org5825420">Guillaume Munch-Maccagnoni replied</h3>
<div class="outline-text-3" id="text-org5825420">
<p>
To answer your question “does de-allocation creates a side-effect?”:
</p>

<p>
To state the obvious: if you care about the memory consumption of your program, then you care about the side-effect of de-allocation, and this indeed voids purity.
</p>

<p>
A language like OCaml lets you reason about de-allocation. Memory is collected when values are no longer reachable. Like in other languages, 1) a value that does not escape and goes out of scope will get collected, and 2) you can reason about when a value escapes and goes out of scope thanks to OCaml respecting the strict evaluation order of value types. OCaml (like other compiled languages) is in fact more precise: it ties the dynamic notion of reachability to the lexical notion of variable occurrence. For instance, in the following:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">x</span> = get_huge_data () <span style="color: #000000; font-weight: bold;">in</span>
<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">z</span> = long_running_function x <span style="color: #000000; font-weight: bold;">in</span>
f z
</pre>
</div>

<p>
OCaml will be able to collect the value in <code>x</code> before <code>x</code> goes out of scope, and thus if possible before <code>long_running_function</code> returns. Indeed, OCaml performs liveness analysis during compilation, and records the information about variable occurrences in frame descriptors, for consumption by the GC when it scans for roots. In fact, you can rely on call-by-value operational semantics to (loosely) reason that a value no longer appears in a program, and therefore that the corresponding memory will be collected by the GC¹ (<a href="https://dash.harvard.edu/handle/1/3293156">Morrisett, Felleisen and Harper, "Abstract Models of Memory Management"</a>). Of course, using lazy or higher-order interfaces (when closures escape; with many idioms they do not) will make it harder to reason about the lifetime of values.
</p>

<p>
(¹: For OCaml, this is a conjecture I make, for subsets which could be given such operational semantics, and only for native compilation. Morrisett, Felleisen and Harper's semantics obviously assumes that the results of liveness analysis are made available to the GC, but this is not written, nor is there any mention of the link between liveness analysis and accuracy of garbage collection in Appel's "Modern Compiler Implementation in C". I assume that it was part of folklore at the time, though recently I mentioned it to some functional PL researcher and they seemed surprised. I only found it explicitly mentioned in later papers from the OOP community. I checked that everything seems in place for OCaml to allow such reasoning, but only the authors of the original code, @xavierleroy and @damiendoligez, can tell us if this is intended to be part of the language semantics.)
</p>

<p>
Furthermore, memory is not collected immediately when a value becomes unreachable. Instead:
</p>

<ul class="org-ul">
<li>Short-lived values are allocated contiguously and deallocated in a batch, so that allocating and deallocating short-lived values is very cheap, with additional benefits in terms of cache locality. This replaces stack allocation from languages with explicit memory management.</li>

<li>Longer-lived values are moved to a heap that is scanned incrementally, to ensure a bounded latency. In contrast, naive reference-counting and unique pointers from C++/Rust make you pay the cost of deallocation up-front.</li>
</ul>

<p>
While this is essential for understanding the performance of OCaml programs, from the point of view of deallocation-as-an-effect, the delaying of the collection of unreachable memory can be seen as a runtime optimisation, that does not change the effectful status of deallocation (the memory still gets freed). [The intuition is that an effect can support some degree of reordering without requiring purity, as illustrated by strong monads which can be commutative without being idempotent, one possible definition of purity for semanticists.]
</p>

<p>
But is de-allocation an effect <span class="underline">in practice</span>? Faced with the scepticism and misunderstandings from this thread, I emit two hypotheses:
</p>

<ol class="org-ol">
<li>Memory consumption is not an issue in functional programming, for application areas that interest functional programmers.</li>

<li>Memory management in OCaml is efficient in such a way that programmers do not need to think about it in their day-to-day programming activities in those terms.</li>
</ol>

<p>
Hypothesis 2) could be explained for instance if OCaml programmers are already dealing with effects and thinking about the order in which their code executes (my experience), and are only used to deal with deallocation as an afterthought, e.g. when chasing leaks with a profiler.
</p>

<p>
Let us turn towards two programming language experiments from the 1990's that allow me to reject hypothesis 1). Both show what happens when one denies the status of deallocation as an effect controlled by the programmer.
</p>

<ul class="org-ul">
<li>Region-based memory management consisted in allocating in a stack of memory <span class="underline">regions</span> deallocated at once, and determined by a whole-program static analysis. Now regarded as a failed idea but successful experiment (i.e. good science!), it taught us a lot about the structure of functional programs in relationship to memory management (<a href="https://link.springer.com/article/10.1023/B:LISP.0000029446.78563.a4">see this retrospective</a>). There were some good performance results, but also pathological cases <span class="underline">“where lifetimes were not nested or where higher-order functions were used extensively”</span>, sometimes requiring them to be altered to be <span class="underline">“region friendly”</span>, which was <span class="underline">“time-consuming”</span> and required knowledge of the inference algorithm. In addition, the regions changed unpredictably when the programs evolved, and memory leaks appeared when the compiler inferred too wide regions.</li>

<li>Haskell was (at the time) an experiment with lazy functional programming. Pervasive laziness prevents reasoning about the lifetime of values, and purity is a central assumption used by the compiler for program transformations, which is antithetical with reasoning about deallocation as an effect. It is well-known that naive Haskell code has issues with memory leaks, and that realistic Haskell programs have to follow "best practices" to avoid leaks, by making extensive use of strictness annotations (e.g. bang patterns). Unfortunately, I found it hard to find reliable academic sources about lessons drawn from the experiment like the RBMM retrospective. The best I could find on the topic of memory leaks is the following blog post: <a href="https://queue.acm.org/detail.cfm?id=2538488">https://queue.acm.org/detail.cfm?id=2538488</a>, from a Haskell programmer who wrote in another post (linked from that one) <span class="underline">“My suspicion is that many (most?) large Haskell programs have space leaks, but they often go unnoticed”</span>. This is consistent with comments I received from people with Haskell experience (first-hand, one academic and one industrial) and about an industrial Haskell consultant (second-hand) who reportedly commented that their main job was to fix memory leaks (but maybe in jest). Of course, take this with a grain of salt. At least, I believe that the Haskell academic community has accumulated empirical evidence of the extent and manner in which deallocation voids purity assumptions. Having an authoritative source about it would be pretty important to me, given the initial promises of functional programs being more tractable mathematically specifically via “referential transparency” and independence of execution order, whose theoretical justification already looks shaky to me from a semantic point of view. Some parts of the literature continues to promise far-reaching consequences of equational reasoning, without clear statements of limitation of the application domain. I have the impression that the Haskell which is practiced in the real world is very different from what you can read in some academic papers.</li>
</ul>

<p>
The hypothesis that deallocation matters as an effect, and that ML makes it easy to program and reason about effects, seems to me a strong argument explaining OCaml's predictable and competitive performance.
</p>

<p>
So, thank you for your healthy scepticism.
</p>
</div>
</div>


<div id="outline-container-org069a6c6" class="outline-3">
<h3 id="org069a6c6">Xavier Leroy replied</h3>
<div class="outline-text-3" id="text-org069a6c6">
<p>
Concerning the "don't scan local variables that are dead" trick:
</p>

<ul class="org-ul">
<li>Technically it is not "intended to be part of the language semantics" because the bytecode compiler (ocamlc) doesn't implement it, only the native-code compiler (ocamlopt).</li>

<li>As far as I remember, I reinvented this trick circa 1993, but it seems it was used earlier in the Lazy ML compiler by Augustsson and Johnsson. See Appel and Shao's paper "An Empirical and Analytic Study of Stack vs. Heap Cost for Languages with Closures", JFP, 1996, end of section 5.</li>
</ul>
</div>
</div>


<div id="outline-container-org4912e34" class="outline-3">
<h3 id="org4912e34">Guillaume Munch-Maccagnoni the asked</h3>
<div class="outline-text-3" id="text-org4912e34">
<p>
TL;DR: the paper mentioned by @xavierleroy provides additional references regarding the importance of liveness analysis for GC, including a demonstration by Appel that this actually matters for space complexity (thanks!). I find that a link is still missing with an abstract semantics à la Morrisett, Felleisen &amp; Harper. This seems important to me because more theoretical works about time &amp; space complexity in the lambda-calculus seem to take for granted that garbage collection implements something like the latter (i.e., how does one specify and certify that a compiler is sound for space complexity?).
</p>
</div>
</div>


<div id="outline-container-orgada9efb" class="outline-3">
<h3 id="orgada9efb">Xavier Leroy replied</h3>
<div class="outline-text-3" id="text-orgada9efb">
<p>
See for example <a href="https://www.cs.princeton.edu/~appel/papers/safe-closure.pdf">Closure Conversion is Safe for Space</a>, by Zoe Paraskevopoulou and Andrew W. Appel, ICFP 2019.
</p>
</div>
</div>
</div>




<div id="outline-container-org7c77234" class="outline-2">
<h2 id="4">A Lightweight OCaml Webapp Tutorial (Using Opium, Caqti, and Tyxml)</h2>
<div class="outline-text-2" id="text-4">
<p>
Archive: <a href="https://discuss.ocaml.org/t/a-lightweight-ocaml-webapp-tutorial-using-opium-caqti-and-tyxml/4967/1">https://discuss.ocaml.org/t/a-lightweight-ocaml-webapp-tutorial-using-opium-caqti-and-tyxml/4967/1</a>
</p>
</div>

<div id="outline-container-orgf1109a0" class="outline-3">
<h3 id="orgf1109a0">Shon announced</h3>
<div class="outline-text-3" id="text-orgf1109a0">
<p>
The tutorial is <a href="https://shonfeder.gitlab.io/ocaml_webapp/">hosted on gitlab pages</a>, out of <a href="https://gitlab.com/anuragsoni/ocaml_webapp">this repository</a>.
</p>

<p>
I put this together in response to some requests for introductory material on the topic (here and on <a href="https://www.reddit.com/r/ocaml/">/r/ocaml</a>. I don't have much expertise to offer in this area, but I had hacked together some simple servers based on Opium in the past few months, so it seemed like I should be able to memorialize some of what I learned for the benefit of others. I received some critical guidance by the Opium maintainers, rgrinberg and anuragsoni, and from other resources online (mentioned at the end of the tutorial).
</p>

<p>
Any feedback or improvements are welcome: this is my first time writing such lengthy instructional material, and I'm sure there's lots of room to make it better.
</p>
</div>
</div>
</div>




<div id="outline-container-org7f361f9" class="outline-2">
<h2 id="5">Release of owl-symbolic 0.1.0</h2>
<div class="outline-text-2" id="text-5">
<p>
Archive: <a href="https://discuss.ocaml.org/t/announce-release-of-owl-symbolic-0-1-0/4930/2">https://discuss.ocaml.org/t/announce-release-of-owl-symbolic-0-1-0/4930/2</a>
</p>
</div>

<div id="outline-container-orge176167" class="outline-3">
<h3 id="orge176167">jrzhao42 announced</h3>
<div class="outline-text-3" id="text-orge176167">
<p>
The Owl tutorial book URL address is now changed to: <a href="https://ocaml.xyz/book/symbolic.html">https://ocaml.xyz/book/symbolic.html</a>.
</p>
</div>
</div>
</div>




<div id="outline-container-org9c780fc" class="outline-2">
<h2 id="6">Static lifetime</h2>
<div class="outline-text-2" id="text-6">
<p>
Archive: <a href="https://discuss.ocaml.org/t/static-lifetime/4908/19">https://discuss.ocaml.org/t/static-lifetime/4908/19</a>
</p>
</div>

<div id="outline-container-orgd99cb66" class="outline-3">
<h3 id="orgd99cb66">André asked and Guillaume Munch-Maccagnoni replied</h3>
<div class="outline-text-3" id="text-orgd99cb66">
<p>
&gt; Is it possible to “statically” allocate a value? By this I mean mark a value such that it gets ignored by the GC and lives until the program exits?
</p>

<p>
This is indeed the purpose of Ancient, which comes with limitations and does not allow you to reclaim the memory until you exit the program. (I am curious to know how well it works with recent OCaml versions.)
</p>

<p>
&gt; it would be really interesting to learn whether Ocaml forbids blocks outside the heap.
</p>

<p>
The OCaml runtime has two modes (chosen at compilation) for dealing with so-called "out-of-heap" pointers. In the legacy one that Chet remembers, the GC uses a page table when scanning to be able to tell which pointers it possesses. In the "no-naked-pointers" mode devised more recently for efficiency reasons, the page table is replaced by looking at the colour in the header of the dereferenced value. Out-of-heap values must be preceded by a header with colour black. The no-naked-pointer mode is more restricted, because once a static value is referenced, it can no longer be deallocated, as you never know whether it is still reachable by the GC. This should be enough to support Ancient.
</p>

<p>
&gt; One should verify such intuitions experimentally, before trying to fix them, but I’m not familiar with what OCaml profilers can do…
</p>

<p>
Excluding large long-lived data from the GC is an old idea. Among recent developments, Nguyen et al. [1] distinguish a "control path" (where the generational hypothesis is assumed to hold) from a "data path" (where values are assumed to follow an "epochal" behaviour (long-lived, similar lifetimes, benefit from locality), and are excluded from GC). They give as motivation so-called "big data" and as figures of pathological GC usage up to 50% of total runtime. I remember reading similar figures from blog posts about large data sets in OCaml. In reality this indeed depends on knobs you can turn on your GC that can result in increased peak memory usage among others. (Assuming infinite available memory, it is even possible to let the GC share drop to 0%.)
</p>

<p>
@ppedrot reported to me that in a recent experiment with Coq, using an Ancient-like trick to exclude some large, long-lived and rarely-accessed values from being scanned (namely serialising them into bigarrays), they saw an 8% performance improvement across the board in benchmarks.
</p>

<p>
Multicore, if I understood correctly, aims to support only the no-naked-pointer mode, and I am not sure what the page table will become. Coq currently does some out-of-heap allocation in the VM, and has been adapted to be compatible with the no-naked-pointer mode by wrapping out-of-heap pointers into custom blocks. For scanning its custom stack (which mixes in-heap and out-of-heap values), Coq sets up a custom root-scanning function (`caml_scan_roots_hook`), which still relies on the page table.
</p>

<p>
Note that having to wrap out-of-heap pointers in custom blocks is (much!) less expressive: for instance with Ancient you can call `List.filter` on a statically-allocated list (and correctly get a GC-allocated list of statically-allocated values). With custom blocks you cannot mix in-heap and out-of-heap values in this way.
</p>

<p>
For a type system to deal with "statically" allocated values, have a look at Rust, which: 1) prevents cycles of reference-counting schemes thanks to uniqueness, 2) can treat GC roots as resources to deal with backpointers at the leaves of the value (cf. the interoperability with SpiderMonkey's GC in Servo). A point of view that I like is that tracing GCs and static allocation differ fundamentally by how they traverse values for collection: traversing live values for the first one, and traversing values at the moment of their death for the other. This gives them distinct advantages and drawbacks so one can see them as complementary. (See notably [2,3].) Static allocation is interesting for performance in some aspects (no tracing, no read-write barrier, reusability of memory cells, avoids calling the GC at inappropriate times), but I find it even more interesting for interoperability (e.g. exchanging values freely with C or Rust, or <a href="https://discuss.ocaml.org/t/using-a-bigarray-as-a-shared-memory-for-parallel-programming/4841/19">applications from that other thread</a>). It is natural to want to mix them in a language.
</p>

<p>
As far as I understand, developing the runtime capabilities for OCaml to deal with out-of-heap pointers without resorting to an expensive page table is an engineering problem, not a fundamental one. If anyone is interested in this, please contact me.
</p>

<p>
[1] Nguyen et al., <a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-nguyen.pdf">Yak : A High-Performance Big-Data-Friendly Garbage Collector</a>, 2016
</p>

<p>
[2] Bacon, Cheng and Rajan, <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.439.1202&amp;rep=rep1&amp;type=pdf">A Unified Theory of Garbage Collection</a>, 2004
</p>

<p>
[3] Shahriyar, Blackburn and Frampton, <a href="https://dl.acm.org/citation.cfm?doid=2258996.2259008">Down for the Count? Getting Reference Counting Back in the Ring</a>, 2012
</p>
</div>
</div>


<div id="outline-container-org7f92de3" class="outline-3">
<h3 id="org7f92de3">UnixJunkie also replied</h3>
<div class="outline-text-3" id="text-org7f92de3">
<p>
If you can store your long-leaved data into a bigarray, I think you would reach the effect that you were looking for (no more GC scanning of this data).
</p>

<p>
This was once advised to me by Oleg, for some performance-critical section of some code.
</p>
</div>
</div>
</div>




<div id="outline-container-orgf226af9" class="outline-2">
<h2 id="orgf226af9">Old CWN</h2>
<div class="outline-text-2" id="text-orgf226af9">
<p>
If you happen to miss a CWN, you can <a href="mailto:alan.schmitt@polytechnique.org">send me a message</a> and I'll mail it to you, or go take a look at <a href="http://alan.petitepomme.net/cwn/">the archive</a> or the <a href="http://alan.petitepomme.net/cwn/cwn.rss">RSS feed of the archives</a>.
</p>

<p>
If you also wish to receive it every week by mail, you may subscribe <a href="http://lists.idyll.org/listinfo/caml-news-weekly/">online</a>.
</p>

<div class="authorname">
<p>
<a href="http://alan.petitepomme.net/">Alan Schmitt</a>
</p>

</div>
</div>
</div>
</div>
</body>
</html>
