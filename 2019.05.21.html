<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-05-21 Tue 16:09 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OCaml Weekly News</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style type="text/css">#table-of-contents h2 { display: none } .title { display: none } .authorname { text-align: right }</style>
<style type="text/css">.outline-2 {border-top: 1px solid black;}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">OCaml Weekly News</h1>
<p>
<a href="http://alan.petitepomme.net/cwn/2019.05.14.html">Previous Week</a> <a href="http://alan.petitepomme.net/cwn/index.html">Up</a> <a href="http://alan.petitepomme.net/cwn/2019.05.28.html">Next Week</a>
</p>

<p>
Hello
</p>

<p>
Here is the latest OCaml Weekly News, for the week of May 14 to 21, 2019.
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#1">override 0.1.0 (initial release)</a></li>
<li><a href="#2">Narrowing variant types alternatives</a></li>
<li><a href="#3">first release of lz4-chans</a></li>
<li><a href="#4">An experimental, unofficial OCaml wiki</a></li>
<li><a href="#5">routes: path based routing for web applications</a></li>
<li><a href="#6">Full schedule for Compose 2019 now available</a></li>
<li><a href="#7">OPAM package: ocaml-monadic</a></li>
<li><a href="#8">De-duplicating module signatures that depend on abstract data types</a></li>
<li><a href="#9">Other OCaml News</a></li>
<li><a href="#org94efb58">Old CWN</a></li>
</ul>
</div>
</div>


<div id="outline-container-org5d288b1" class="outline-2">
<h2 id="1">override 0.1.0 (initial release)</h2>
<div class="outline-text-2" id="text-1">
<p>
Archive: <a href="https://discuss.ocaml.org/t/ann-override-0-1-0-initial-release/3797/1">https://discuss.ocaml.org/t/ann-override-0-1-0-initial-release/3797/1</a>
</p>
</div>

<div id="outline-container-org163d217" class="outline-3">
<h3 id="org163d217">Thierry Martinez announced</h3>
<div class="outline-text-3" id="text-org163d217">
<p>
I am happy to announce the first release of override (v0.1.0)!
</p>

<p>
Override is a PPX extension for overriding modules defined in other compiled interface files.
</p>

<p>
The library is available through opam: <code>opam install override</code>
</p>

<p>
The project is hosted on Inria Gitlab:
<a href="https://gitlab.inria.fr/tmartine/override">https://gitlab.inria.fr/tmartine/override</a>
</p>

<p>
See <code>README.md</code> for usage and examples.
</p>

<p>
This library generalizes <code>ppx_import</code> by allowing a whole module to be imported with all its types, possibly with annotations.  In particular, importing a whole module can be convenient to apply
<code>ppx_deriving</code> to a large family of mutually inductive data types. Types can be systematically annotated, substituted, renamed, or removed.  The library can be seen as a mechanization of @gasche's post on Gagallium blog:
<a href="http://gallium.inria.fr/blog/overriding-submodules/">http://gallium.inria.fr/blog/overriding-submodules/</a>
</p>

<p>
Happy hacking.
</p>
</div>
</div>
</div>




<div id="outline-container-org3d7b02e" class="outline-2">
<h2 id="2">Narrowing variant types alternatives</h2>
<div class="outline-text-2" id="text-2">
<p>
Archive: <a href="https://discuss.ocaml.org/t/narrowing-variant-types-alternatives/3806/1">https://discuss.ocaml.org/t/narrowing-variant-types-alternatives/3806/1</a>
</p>
</div>

<div id="outline-container-org37d300a" class="outline-3">
<h3 id="org37d300a">Alejandro Lopez asked</h3>
<div class="outline-text-3" id="text-org37d300a">
<p>
Consider the following type representing types in a programming language:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">t</span> =
  | <span style="color: #000000; background-color: #ffffff;">Name</span> <span style="color: #a020f0;">of</span> string
  | <span style="color: #000000; background-color: #ffffff;">Record</span> <span style="color: #a020f0;">of</span> (string * t) list
  | <span style="color: #000000; background-color: #ffffff;">Array</span> <span style="color: #a020f0;">of</span> (t * int)
</pre>
</div>

<p>
Is there a way to limit the type <code>t</code> in <code>Array of (t * int)</code> to be only a <code>Name</code> or <code>Array</code>? i.e. I would like the following to cause a compile error:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">_</span> = <span style="color: #000000; background-color: #ffffff;">Array</span> (<span style="color: #000000; background-color: #ffffff;">Record</span> <span style="color: #000000; background-color: #ffffff;">[]</span>) <span style="color: #000000; font-weight: bold;">in</span>
<span style="color: #b22222;">(* </span><span style="color: #b22222;">... </span><span style="color: #b22222;">*)</span>
</pre>
</div>
<p>
so that <code>Array</code> types can only be built from <code>Name</code> or <code>Array</code> constructors. Currently I find myself with a few special conditions during runtime that cannot possibly happen but that I need to check for exhaustiveness, because I don't know how to encode a more strict representation.
</p>

<p>
I hope I explained myself, I'm a beginner to the language. Thanks.
</p>
</div>
</div>


<div id="outline-container-orgc2e49c9" class="outline-3">
<h3 id="orgc2e49c9">Ivan Gotovchits replied</h3>
<div class="outline-text-3" id="text-orgc2e49c9">
<p>
Yes, you can use GADT exactly for this purpose
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">scalar</span> = <span style="color: #000000; background-color: #ffffff;">Scalar</span>
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">vector</span> = <span style="color: #000000; background-color: #ffffff;">Vector</span>
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">_ t</span> =
  | <span style="color: #000000; background-color: #ffffff;">Name</span> : string -&gt; scalar t
  | <span style="color: #000000; background-color: #ffffff;">Record</span> : string * _ t -&gt; vector t
  | <span style="color: #000000; background-color: #ffffff;">Array</span> : scalar t * int -&gt; scalar t
</pre>
</div>

<p>
Probably, I chose the wrong names for type constraints :slight_smile:
</p>

<p>
Another option would to use polymorphic variants, but this will require some restructuring of your original design. For an example, you can look into the <a href="https://github.com/BinaryAnalysisPlatform/bap/blob/master/lib/bap_c/bap_c_type.ml">C type system</a> representation in BAP.
</p>
</div>
</div>


<div id="outline-container-org8597c2a" class="outline-3">
<h3 id="org8597c2a">Vladimir Keleshev also replied</h3>
<div class="outline-text-3" id="text-org8597c2a">
<p>
@ivg's GADT suggestion is probably the most ergonomic one, but for completeness, here are two others, an ADT one, and one using polymorphic variants (as also suggested by @ivg).
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">ADT</span> = <span style="color: #000000; font-weight: bold;">struct</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">not_record</span> =
    | <span style="color: #000000; background-color: #ffffff;">Name</span> <span style="color: #a020f0;">of</span> string
    | <span style="color: #000000; background-color: #ffffff;">List</span> <span style="color: #a020f0;">of</span> t
    | <span style="color: #000000; background-color: #ffffff;">Array</span> <span style="color: #a020f0;">of</span> (not_record * int)
  <span style="color: #000000; font-weight: bold;">and</span> <span style="color: #a0522d;">t</span> =
    | <span style="color: #000000; background-color: #ffffff;">Record</span> <span style="color: #a020f0;">of</span> (string * t) list
    | <span style="color: #000000; background-color: #ffffff;">Not_record</span> <span style="color: #a020f0;">of</span> not_record
<span style="color: #000000; font-weight: bold;">end</span>

<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Polymorphic_variants</span> = <span style="color: #000000; font-weight: bold;">struct</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'r not_record</span> = [
    | <span style="color: #000000; background-color: #ffffff;">`Name</span> <span style="color: #a020f0;">of</span> string
    | <span style="color: #000000; background-color: #ffffff;">`List</span> <span style="color: #a020f0;">of</span> 'r <span style="color: #b22222;">(* </span><span style="color: #b22222;">any t is allowed </span><span style="color: #b22222;">*)</span>
    | <span style="color: #000000; background-color: #ffffff;">`Array</span> <span style="color: #a020f0;">of</span> 'r not_record * int
  ]

  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'r t_open</span> = [
    | <span style="color: #000000; background-color: #ffffff;">`Record</span> <span style="color: #a020f0;">of</span> (string * 'r) list
    | 'r not_record
  ]

  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">t</span> = t t_open

  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">_</span> :<span style="color: #228b22;"> t </span>= <span style="color: #000000; background-color: #ffffff;">`List</span> (<span style="color: #000000; background-color: #ffffff;">`Record</span> [<span style="color: #8b2252;">"foo"</span>, <span style="color: #000000; background-color: #ffffff;">`Array</span> (<span style="color: #000000; background-color: #ffffff;">`List</span> (<span style="color: #000000; background-color: #ffffff;">`Record</span> <span style="color: #000000; background-color: #ffffff;">[]</span>), 10)])

  <span style="color: #b22222;">(* </span><span style="color: #b22222;">Does not type-check:</span>
<span style="color: #b22222;">  let _ : t = `List (`Record ["foo", `Array (`Record [], 10)]) </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
The disadvantage of the ADT solution is that you need the <code>Not_record</code> constructor, but smart constructors could help in this case.
</p>

<p>
The disadvantage of the polymorphic variant solution is that it only catches your invariant violation if the value is type-annotated.
</p>
</div>
</div>


<div id="outline-container-orgf444975" class="outline-3">
<h3 id="orgf444975">Chet Murthy then asked and Ivan Gotovchits replied</h3>
<div class="outline-text-3" id="text-orgf444975">
<p>
&gt; This is what private constructors were supposed to be for, right?
</p>

<p>
Not really, they could be used as a part of a solution which is more practical than GADT.
</p>
</div>

<div id="outline-container-org2dfe8e5" class="outline-4">
<h4 id="org2dfe8e5">What's wrong with GADT?</h4>
<div class="outline-text-4" id="text-org2dfe8e5">
<p>
The problem with GADT is that they mix two orthogonal concepts - types and data representation (aka data types). While ADT define data representation, constraints, attached to GADT constructors, are pure types, as their only purpose is to constrain the set to which the type belongs. On one hand it is very nice, we can kill two rabbits at once, construct data and prove its correctness by construction. But this comes with a price because you have to repeat the proof every time you reconstruct your data. In other words, you can't serialize and deserialize your GADT, as the constraint itself is not serializable (because it is not data).
</p>

<p>
Therefore, in real life, where you occasionally need to pass your AST around different hosts, store them in cache and files, etc, using GADT immediately becomes a nuisance. As every time when you need to read your AST from a string, you have to repeat the process of proving by construction. In other words, you need to write a typed parser, that does parsing (data processing) and typing simultaneously. This is notoriously hard and, in fact, is only possible in a small number of simple cases. E.g., it is practically¹ impossible to reconstruct an arrow type from its string representation,
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a app</span> =
  | <span style="color: #000000; background-color: #ffffff;">Unit</span> : unit app
  | <span style="color: #000000; background-color: #ffffff;">App</span> : 'a * 'b app -&gt; ('a -&gt; 'b) app
</pre>
</div>
</div>
</div>

<div id="outline-container-org65ddc09" class="outline-4">
<h4 id="org65ddc09">Separate the concerns</h4>
<div class="outline-text-4" id="text-org65ddc09">
<p>
Therefore, a practical solution would be to separate the concerns back and use ADT for data types, and module types for types. In other words, we will hide our data representation behind an abstraction wall. And we may even use the <code>private</code> keyword to allow others to peek into our privates through the holes in our abstraction wall.
</p>

<p>
The approach basically mimics the GADT approach, except that we move the constraints into the module type,
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Types</span> : <span style="color: #000000; font-weight: bold;">sig</span> =
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">scalar</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">vector</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">data</span> = <span style="color: #a020f0;">private</span>
    | <span style="color: #000000; background-color: #ffffff;">Name</span> <span style="color: #a020f0;">of</span> string
    | <span style="color: #000000; background-color: #ffffff;">Record</span> <span style="color: #a020f0;">of</span> (string * data) list
    | <span style="color: #000000; background-color: #ffffff;">Array</span> <span style="color: #a020f0;">of</span> (data * int)

  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a t</span> = data
  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">name</span> : string -&gt; scalar t
  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">record</span> : (string * _ t) list -&gt; vector t
  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">array</span> : scalar t -&gt; int -&gt; scalar t
<span style="color: #000000; font-weight: bold;">end</span> = <span style="color: #000000; font-weight: bold;">struct</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">scalar</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">vector</span>

  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">data</span> =
    | <span style="color: #000000; background-color: #ffffff;">Name</span> <span style="color: #a020f0;">of</span> string
    | <span style="color: #000000; background-color: #ffffff;">Record</span> <span style="color: #a020f0;">of</span> (string * data) list
    | <span style="color: #000000; background-color: #ffffff;">Array</span> <span style="color: #a020f0;">of</span> (data * int)

   <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a t</span> = data

   <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">name</span> <span style="color: #a0522d;">x</span> = <span style="color: #000000; background-color: #ffffff;">Name</span> x
   <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">record</span> <span style="color: #a0522d;">elts</span> = <span style="color: #000000; background-color: #ffffff;">Record</span> (elts)
   <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">array</span> <span style="color: #a0522d;">elt</span> <span style="color: #a0522d;">sz</span> = <span style="color: #000000; background-color: #ffffff;">Array</span> (elt,sz)
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
Now, our invariant is protected, so that nobody outside of the module could create an incorrect tree. However, inside the module, behind the wall, we are free to do whatever we want, since the constraint is now a phantom type, the compiler will allow us to ascribe any type to any tree. Of course, it will allow us to ascribe wrong types, so it is now our responsibility to implement the type checker correctly. But now we can read our data from text and give it back the type constraint. We can even reify the type constraint into a concrete data type representation and store it with AST.
</p>

<p>
In this solution we use the <code>private</code> keyword to expose some of our abstraction. So that a user could use a regular pattern match, however this highlights a small problem. When we turned away from GADT we lost an important feature, as beyond proving the data type is constructed correctly, GADT enables us to use this proof when we deconstruct the data.  With our plain ADT representation, which is now impossible to construct incorrectly (using the <code>Types</code> interface), we still have to deal with an extra case, when we do
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #a020f0;">function</span> <span style="color: #000000; background-color: #ffffff;">Array</span> (elt,n) -&gt; <span style="color: #a020f0;">match</span> elt <span style="color: #a020f0;">with</span>
  | <span style="color: #000000; background-color: #ffffff;">Name</span> s -&gt; name s
  | <span style="color: #000000; background-color: #ffffff;">Array</span> (elt',m) -&gt; array elt m
  | <span style="color: #000000; background-color: #ffffff;">Record</span> _ -&gt; <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span>
</pre>
</div>

<p>
Since we don't have the constraints anymore, the compiler can't refute the Record branch (and indeed, an incorrect code inside of the <code>Types</code> module can construct such representation, so we can't blame the compiler for that.
</p>

<p>
And although <code>assert false</code> is more or less fine here, we don't want a casual user to rely on our internal invariants (an even know about them because an invariant, that leaks the module is no longer an invariant). The reason why the invariant escaped is because we exposed our internal representation, we leaked it through the abstraction via the <code>private</code> keyword. Therefore, the solution is to hide it,
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Types</span> : <span style="color: #000000; font-weight: bold;">sig</span> =
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">scalar</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">vector</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">_ t</span>

  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">name</span> : string -&gt; scalar t
  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">record</span> : (string * _ t) list -&gt; vector t
  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">array</span> : scalar t -&gt; int -&gt; scalar t

  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">case</span> : _ t -&gt;
     <span style="color: #008b8b;">scalar</span>:(scalar t -&gt; 'a)
     vector:(vector t -&gt; 'a) -&gt; 'a

  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">match_scalar</span> : scalar t -&gt;
      <span style="color: #008b8b;">name</span>:(string -&gt; 'a) -&gt;
      <span style="color: #008b8b;">array</span>:(scalar t -&gt; int -&gt; 'a) -&gt; 'a

  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">match_vector</span> : vector t -&gt;
     <span style="color: #008b8b;">record</span>:((string * _ t) list -&gt; 'a) -&gt; 'a

<span style="color: #000000; font-weight: bold;">end</span> = <span style="color: #000000; font-weight: bold;">struct</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">scalar</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">vector</span>

  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">data</span> =
    | <span style="color: #000000; background-color: #ffffff;">Name</span> <span style="color: #a020f0;">of</span> string
    | <span style="color: #000000; background-color: #ffffff;">Record</span> <span style="color: #a020f0;">of</span> (string * data) list
    | <span style="color: #000000; background-color: #ffffff;">Array</span> <span style="color: #a020f0;">of</span> (data * int)

   <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a t</span> = data

   <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">name</span> <span style="color: #a0522d;">x</span> = <span style="color: #000000; background-color: #ffffff;">Name</span> x
   <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">record</span> <span style="color: #a0522d;">elts</span> = <span style="color: #000000; background-color: #ffffff;">Record</span> (elts)
   <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">array</span> <span style="color: #a0522d;">elt</span> <span style="color: #a0522d;">sz</span> = <span style="color: #000000; background-color: #ffffff;">Array</span> (elt,sz)

   <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">case</span> <span style="color: #a0522d;">t</span> ~<span style="color: #a0522d;">scalar</span> ~<span style="color: #a0522d;">vector</span> = <span style="color: #a020f0;">match</span> t <span style="color: #a020f0;">with</span>
     | <span style="color: #000000; background-color: #ffffff;">Record</span> _ -&gt; vector t
     | <span style="color: #000000; background-color: #ffffff;">Array</span> _ | <span style="color: #000000; background-color: #ffffff;">Name</span> _ -&gt; scalar t

   <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">match_scalar</span> <span style="color: #a0522d;">t</span> ~<span style="color: #a0522d;">name</span> ~<span style="color: #a0522d;">array</span>  = <span style="color: #a020f0;">match</span> t <span style="color: #a020f0;">with</span>
    | <span style="color: #000000; background-color: #ffffff;">Array</span> (elt,sz) -&gt; array elt sz
    | <span style="color: #000000; background-color: #ffffff;">Name</span> s -&gt; name s
    | _ -&gt; <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span>

  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">match_vector</span> <span style="color: #a0522d;">t</span> ~<span style="color: #a0522d;">record</span> = <span style="color: #a020f0;">match</span> t <span style="color: #a020f0;">with</span>
    | <span style="color: #000000; background-color: #ffffff;">Record</span> elts -&gt; record elts
    | _ -&gt; <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span>
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
We confined our invariant inside our module, and we can use <code>assert false</code> which could be triggered only if we bugged our code inside of the <code>Types</code> modules, which is now considered the trusted kernel.
</p>

<p>
The users of our module now can use the whole power of constraints, and basically, use our typed AST as it was GADTs but without any pain associated with them.
</p>
</div>
</div>

<div id="outline-container-org705d036" class="outline-4">
<h4 id="org705d036">Final Solution, Tagless Final</h4>
<div class="outline-text-4" id="text-org705d036">
<p>
Finally, we can notice, that cases in our matches totally mimic the types of our branch constructors and this smells like a generalization opportunity. Indeed, we can abstract our abstraction into the module type
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #b22222;">(* </span><span style="color: #b22222;">keep constraints not abstract, and make them provably distinct in</span>
<span style="color: #b22222;">    case if someone would like to use GADT in their representations.  </span><span style="color: #b22222;">*)</span>

<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">scalar</span> = <span style="color: #a020f0;">private</span> <span style="color: #000000; background-color: #ffffff;">Scalar_constraint</span>
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">vector</span> = <span style="color: #a020f0;">private</span> <span style="color: #000000; background-color: #ffffff;">Vector_constraint</span>

<span style="color: #000000; font-weight: bold;">module type</span> <span style="color: #228b22;">Types</span> = <span style="color: #000000; font-weight: bold;">sig</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">_ t</span>

  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">name</span> : string -&gt; scalar t
  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">record</span> : (string * _ t) list -&gt; vector t
  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">array</span> : scalar t -&gt; int -&gt; scalar t
<span style="color: #000000; font-weight: bold;">end</span>

<span style="color: #b22222;">(* </span><span style="color: #b22222;">our old Types module is just _a_ representation, let's call</span>
<span style="color: #b22222;">   it an AST </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Ast</span> : <span style="color: #000000; font-weight: bold;">sig</span>
  <span style="color: #000000; font-weight: bold;">include</span> <span style="color: #228b22;">Types</span>

  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">case</span> : 'a t -&gt;
    <span style="color: #008b8b;">scalar</span> : (scalar t -&gt; 'a) -&gt;
    <span style="color: #008b8b;">vector</span> : (vector t -&gt; 'a) -&gt; 'a

  <span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Analysis</span><span style="color: #a0522d;">(L :</span><span style="color: #228b22;"> Types</span><span style="color: #a0522d;">) </span>: <span style="color: #000000; font-weight: bold;">sig</span>
    <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">scalar</span> : scalar t -&gt; scalar <span style="color: #228b22;">L.</span>t
    <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">vector</span> : vector t -&gt; vector <span style="color: #228b22;">L.</span>t
  <span style="color: #000000; font-weight: bold;">end</span>
<span style="color: #000000; font-weight: bold;">end</span> = <span style="color: #000000; font-weight: bold;">struct</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">data</span> =
    | <span style="color: #000000; background-color: #ffffff;">Name</span> <span style="color: #a020f0;">of</span> string
    | <span style="color: #000000; background-color: #ffffff;">Record</span> <span style="color: #a020f0;">of</span> (string * data) list
    | <span style="color: #000000; background-color: #ffffff;">Array</span> <span style="color: #a020f0;">of</span> (data * int)

  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a t</span> = data

  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">name</span> <span style="color: #a0522d;">x</span> = <span style="color: #000000; background-color: #ffffff;">Name</span> x
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">record</span> <span style="color: #a0522d;">elts</span> = <span style="color: #000000; background-color: #ffffff;">Record</span> (elts)
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">array</span> <span style="color: #a0522d;">elt</span> <span style="color: #a0522d;">sz</span> = <span style="color: #000000; background-color: #ffffff;">Array</span> (elt,sz)

  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">case</span> <span style="color: #a0522d;">x</span> ~<span style="color: #a0522d;">scalar</span> ~<span style="color: #a0522d;">vector</span> = <span style="color: #a020f0;">match</span> x <span style="color: #a020f0;">with</span>
    | <span style="color: #000000; background-color: #ffffff;">Name</span> _ | <span style="color: #000000; background-color: #ffffff;">Array</span> _ -&gt; scalar x
    | <span style="color: #000000; background-color: #ffffff;">Record</span> _ -&gt; vector x

  <span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Analysis</span><span style="color: #a0522d;">(L :</span><span style="color: #228b22;"> Types</span><span style="color: #a0522d;">) </span>= <span style="color: #000000; font-weight: bold;">struct</span>

    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">scalar</span> = <span style="color: #a020f0;">function</span>
      | <span style="color: #000000; background-color: #ffffff;">Name</span> s -&gt; <span style="color: #228b22;">L.</span>name s
      | <span style="color: #000000; background-color: #ffffff;">Array</span> (elt,sz) -&gt; <span style="color: #228b22;">L.</span>array (scalar elt) sz
      | <span style="color: #000000; background-color: #ffffff;">Record</span> _ -&gt; <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span>

    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #000000; font-weight: bold;">rec</span> <span style="color: #0000ff;">vector</span> = <span style="color: #a020f0;">function</span>
      | <span style="color: #000000; background-color: #ffffff;">Name</span> _ | <span style="color: #000000; background-color: #ffffff;">Array</span> _ -&gt; <span style="color: #a020f0;">assert</span> <span style="color: #008b8b;">false</span>
      | <span style="color: #000000; background-color: #ffffff;">Record</span> ((_, (<span style="color: #000000; background-color: #ffffff;">Name</span> _ | <span style="color: #000000; background-color: #ffffff;">Array</span> _)) <span style="color: #000000; background-color: #ffffff;">::</span> _ <span style="color: #a020f0;">as</span> elts) -&gt;
        <span style="color: #228b22;">L.</span>record <span style="color: #a52a2a;">@@</span>
        <span style="color: #228b22;">List.</span>map (<span style="color: #a020f0;">fun</span> (<span style="color: #a0522d;">name</span>,<span style="color: #a0522d;">fld</span>) -&gt; name, scalar fld) elts
      | <span style="color: #000000; background-color: #ffffff;">Record</span> elts -&gt;
        <span style="color: #228b22;">L.</span>record <span style="color: #a52a2a;">@@</span>
        <span style="color: #228b22;">List.</span>map (<span style="color: #a020f0;">fun</span> (<span style="color: #a0522d;">name</span>,<span style="color: #a0522d;">fld</span>) -&gt; name, vector fld) elts
  <span style="color: #000000; font-weight: bold;">end</span>
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
And now we can implement the analysis as simple as,
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Sizeof</span> = <span style="color: #228b22;">Ast.Analysis</span>(<span style="color: #000000; font-weight: bold;">struct</span>
    <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a t</span> = int
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">name</span> <span style="color: #a0522d;">_</span> = 4
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">array</span> <span style="color: #a0522d;">elt</span> <span style="color: #a0522d;">sz</span> = elt * sz
    <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">record</span> <span style="color: #a0522d;">elts</span> = <span style="color: #228b22;">List.</span>fold_left (<span style="color: #a020f0;">fun</span> <span style="color: #a0522d;">s</span> (<span style="color: #a0522d;">_</span>,<span style="color: #a0522d;">sz</span>) -&gt; s + sz) 0  elts
  <span style="color: #000000; font-weight: bold;">end</span>)

<span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">sizeof</span> <span style="color: #a0522d;">t</span> = <span style="color: #228b22;">Ast.</span>case t
    <span style="color: #008b8b;">~scalar</span>:<span style="color: #228b22;">Sizeof.</span>scalar
    <span style="color: #008b8b;">~vector</span>:<span style="color: #228b22;">Sizeof.</span>vector
</pre>
</div>

<p>
This approach is called <a href="http://okmij.org/ftp/tagless-final/index.html">Taggles Final Style</a> and is well-explored.
</p>
</div>
</div>

<div id="outline-container-org8017096" class="outline-4">
<h4 id="org8017096">A few grains of salt</h4>
<div class="outline-text-4" id="text-org8017096">
<p>
Although it all may look nice (or vice verse), there is a grain of salt. It doesn't work as we have a problem in our original design, we dropped the type constraint of the record constructor. In other words, our record constructor, <code>(string * 'a t) -&gt; scalar t</code> is non-injective, as it projects different types into the same type. Therefore we can't reconstruct the constraint back. Therefore, probably a better type system representation would be
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">array</span> = array
<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a tuple</span> = <span style="color: #000000; background-color: #ffffff;">Tuple</span>

<span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a t</span>
<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">array</span> : array t -&gt; int -&gt; array t
<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">tuple</span> : 'a t -&gt; 'b tuple t -&gt; ('a -&gt; 'b) tuple t
<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">unit</span> : unit tuple t
</pre>
</div>

<p>
and the case analysis will look something like this
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">case</span> : _ t -&gt;
  <span style="color: #008b8b;">unit</span> : (() -&gt; 'a) -&gt;
  <span style="color: #008b8b;">tuple</span> : (('a -&gt; 'b) tuple t -&gt; 'a) -&gt;
  <span style="color: #008b8b;">array</span> : (array t -&gt; 'a) -&gt; 'a
<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">split</span> : ('a -&gt; 'b) tuple t -&gt; 'a t * 'b tuple t
</pre>
</div>

<p>
¹: You can do this for a fixed number of constraints, e.g., <code>int -&gt; unit</code>, <code>int -&gt; string -&gt; unit</code>, etc, not for arbitrary constraint. You would need a backtracking parser, which will try on each branch all possible cases. As a result, not only the performance will suffer, but the complexity of the parser itself.
</p>
</div>
</div>
</div>
</div>




<div id="outline-container-org8ef2811" class="outline-2">
<h2 id="3">first release of lz4-chans</h2>
<div class="outline-text-2" id="text-3">
<p>
Archive: <a href="https://discuss.ocaml.org/t/ann-first-release-of-lz4-chans/3818/1">https://discuss.ocaml.org/t/ann-first-release-of-lz4-chans/3818/1</a>
</p>
</div>

<div id="outline-container-org0ab29ee" class="outline-3">
<h3 id="org0ab29ee">UnixJunkie announced</h3>
<div class="outline-text-3" id="text-org0ab29ee">
<p>
It is my pleasure to announce the first release of lz4_chans:
</p>

<p>
<a href="https://github.com/UnixJunkie/lz4-chans">https://github.com/UnixJunkie/lz4-chans</a>
</p>

<p>
You can use them as drop-in replacement for the channels provided
by the stdlib:
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #8b2252;">(** open/close binary channels, with LZ4-compression</span>
<span style="color: #8b2252;">    happening in the background, using a separate process and a named pipes *)</span>

<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">open_in_bin</span>: string -&gt; in_channel
<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">open_out_bin</span>: string -&gt; out_channel

<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">close_in</span>: in_channel -&gt; unit
<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">close_out</span>: out_channel -&gt; unit

<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">with_in_file</span>: string -&gt; (in_channel -&gt; 'a) -&gt; 'a
<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">with_out_file</span>: string -&gt; (out_channel -&gt; 'a) -&gt; 'a
</pre>
</div>

<p>
It was fun to write this little system programming thing.
</p>

<p>
Performance tests on my computer:
</p>
<pre class="example">
2019-05-17 16:38:40.483 INFO : plain_fn: /tmp/lz4_chans_test_1b1d6a.bin
2019-05-17 16:38:41.847 INFO : plain output: 7335450.09 floats/s
2019-05-17 16:38:42.670 INFO : plain input: 12191301.78 floats/s
2019-05-17 16:38:42.686 INFO : lz4_fn: /tmp/lz4_chans_test_8b6517.bin.lz4
2019-05-17 16:38:45.348 INFO : lz4 output: 3757097.68 floats/s; eficiency: 0.51
2019-05-17 16:38:46.518 INFO : lz4 input: 8557598.32 floats/s; efficiency: 0.70
</pre>
</div>
</div>
</div>




<div id="outline-container-org0969db1" class="outline-2">
<h2 id="4">An experimental, unofficial OCaml wiki</h2>
<div class="outline-text-2" id="text-4">
<p>
Archive: <a href="https://discuss.ocaml.org/t/an-experimental-unofficial-ocaml-wiki/1972/21">https://discuss.ocaml.org/t/an-experimental-unofficial-ocaml-wiki/1972/21</a>
</p>
</div>

<div id="outline-container-org8f5e157" class="outline-3">
<h3 id="org8f5e157">Resurrecting this old thread, Yotam Barnoy said</h3>
<div class="outline-text-3" id="text-org8f5e157">
<p>
We just got a nice redesign courtesy of @fallbackusername ! If you haven't checked <a href="https://ocamlverse.github.io">ocamlverse</a> out yet, come do so!
</p>
</div>
</div>
</div>




<div id="outline-container-org6ec28c8" class="outline-2">
<h2 id="5">routes: path based routing for web applications</h2>
<div class="outline-text-2" id="text-5">
<p>
Archive: <a href="https://discuss.ocaml.org/t/ann-routes-path-based-routing-for-web-applications/3624/5">https://discuss.ocaml.org/t/ann-routes-path-based-routing-for-web-applications/3624/5</a>
</p>
</div>

<div id="outline-container-org9938d7b" class="outline-3">
<h3 id="org9938d7b">Continuing this thread, Anurag Soni announced</h3>
<div class="outline-text-3" id="text-org9938d7b">
<p>
Few more updates:
</p>

<ul class="org-ul">
<li>This is now available on opam to make it easy to try it out (<a href="http://opam.ocaml.org/packages/routes/">http://opam.ocaml.org/packages/routes/</a>)</li>
<li>Internally routes are now grouped on the HTTP methods wherever possible</li>
<li>The combinators translate the route definitions into a trie (this allowed to share the prefix matching on all routes)</li>
<li>A little bit of route re-writing is done to avoid un-necessary nested skip/apply actions.</li>
<li>I added an example about how this can be used as an Opium middleware.</li>
</ul>

<p>
I have given up on some features from before (removed route printing, and nested routing are now removed)
</p>

<p>
Please let me know of any issues/problems you notice if you decide to try it out :slight_smile:
</p>
</div>
</div>
</div>




<div id="outline-container-org93650e0" class="outline-2">
<h2 id="6">Full schedule for Compose 2019 now available</h2>
<div class="outline-text-2" id="text-6">
<p>
Archive: <a href="https://discuss.ocaml.org/t/full-schedule-for-compose-2019-nyc-june-24-25-now-available/3829/1">https://discuss.ocaml.org/t/full-schedule-for-compose-2019-nyc-june-24-25-now-available/3829/1</a>
</p>
</div>

<div id="outline-container-org5526233" class="outline-3">
<h3 id="org5526233">Gbaz announced</h3>
<div class="outline-text-3" id="text-org5526233">
<p>
The practice and craft of functional programming :: Conference
</p>

<p>
Compose is a conference for typed functional programmers, focused specifically on Haskell, OCaml, F#, SML, and related technologies. This year it has a host of great talks of interest to OCaml developers.
</p>
</div>

<div id="outline-container-org4512690" class="outline-4">
<h4 id="org4512690">Invited Keynotes</h4>
<div class="outline-text-4" id="text-org4512690">
<ul class="org-ul">
<li>Donya Quick - Making Algorithmic Music</li>
<li>David Spivak - Compositional Graphical Logic</li>
</ul>
</div>
</div>

<div id="outline-container-orge30de77" class="outline-4">
<h4 id="orge30de77">Accepted Talks and Tutorials</h4>
<div class="outline-text-4" id="text-orge30de77">
<ul class="org-ul">
<li>Kenny Foner - Functors of the World, Unite!</li>
<li>Phillip Carter - The anatomy of the F# tools for Visual Studio</li>
<li>Sebastien Mondet - Genspio: Generating Shell Phrases In OCaml</li>
<li>Justin Le - Applicative Regular Expressions using the Free Alternative</li>
<li>Gaetano Checinski - Buckaroo SAT - Solving a partially revealed SAT</li>
<li>problem for Package Management</li>
<li>Richard Feldman - From Rails to Elm and Haskell</li>
<li>Samuel Gélineau - Stuck macros: deterministically interleaving</li>
<li>macro-expansion and typechecking</li>
<li>Vaibhav Sagar - Yes, IHaskell Can Do That!</li>
<li>Fintan Halpenny - Bowl Full of Lentils</li>
<li>Aditya Siram - A Tase Of ATS</li>
<li>Ward Wheeler, Alex Washburn, Callan McGill - Phylogenetic Software in Haskell</li>
<li>Igor Trindade Oliveira - Type Driven Secure Enclave Development using Idris</li>
<li>David Christiansen - Bidirectional Type Checking</li>
<li>Chris Smith - Teaching the intersection of mathematics and functional programming</li>
<li>Brandon Kase - Fast Accumulation on Streams</li>
<li>James Koppel - The Best Refactoring You’ve Never Heard Of</li>
<li>Allister Beharry - Using Dependent Types in an F# DSL for Linear Algebra</li>
<li>Diego Balseiro - Bridge Haskell and ReasonML in Production</li>
</ul>
</div>
</div>

<div id="outline-container-org38136fc" class="outline-4">
<h4 id="org38136fc">Full abstracts</h4>
<div class="outline-text-4" id="text-org38136fc">
<p>
<a href="http://www.composeconference.org/2019/program">http://www.composeconference.org/2019/program</a>
</p>
</div>
</div>

<div id="outline-container-orgab831d9" class="outline-4">
<h4 id="orgab831d9">Conference Registration</h4>
<div class="outline-text-4" id="text-orgab831d9">
<p>
<a href="https://www.eventbrite.com/e/new-york-compose-2019-tickets-56751182314">https://www.eventbrite.com/e/new-york-compose-2019-tickets-56751182314</a>
</p>
</div>
</div>
</div>
</div>




<div id="outline-container-orga4a287b" class="outline-2">
<h2 id="7">OPAM package: ocaml-monadic</h2>
<div class="outline-text-2" id="text-7">
<p>
Archive: <a href="https://discuss.ocaml.org/t/opam-package-ocaml-monadic/3828/1">https://discuss.ocaml.org/t/opam-package-ocaml-monadic/3828/1</a>
</p>
</div>

<div id="outline-container-org3903be5" class="outline-3">
<h3 id="org3903be5">Zach announced</h3>
<div class="outline-text-3" id="text-org3903be5">
<p>
Hello!  I was just repackaging a little library for OPAM 2 the other day when one of the repository maintainers pointed out that I should probably make mention of it on this forum (given that I never have).  The package name is "ocaml-monadic"; it provides ppx extensions for monadic syntax in a way that blends with OCaml's existing grammar.  Here's a link:
</p>

<p>
<a href="https://github.com/zepalmer/ocaml-monadic">https://github.com/zepalmer/ocaml-monadic</a>
</p>

<p>
I optimistically anticipate the following questions enough to provide answers:
</p>

<p>
Q1. Why? <br />
A1. Because switching between monadic and non-monadic syntax shouldn't require rewriting everything.  Also because I wanted to learn PPX extensions in 2015.  :)
</p>

<p>
Q2. Does the library require or use any specific library when dealing with monads? <br />
A2. No.  It just assumes the locally-scoped use of the names "bind" and, in some cases, "zero".
</p>

<p>
Q3. How is this different from Jane Street's <a href="https://github.com/janestreet/ppx_let">ppx_let</a> library? <br />
A3. There are some miscellaneous differences ("%map" in ppx_let vs. "%orzero" in ocaml-monadic), but they're largely the same idea.  Their first versions were released at roughly the same time.
</p>
</div>
</div>


<div id="outline-container-orga03757b" class="outline-3">
<h3 id="orga03757b">octachron said and Hezekiah Carty replied</h3>
<div class="outline-text-3" id="text-orga03757b">
<p>
&gt; Note that monadic and applicative notations will be directly supported by the compiler itself starting from 4.08.
</p>

<p>
One upside to ocaml-monadic (and ppx_let and lwt_ppx) compared with 4.08's <code>let</code> operators is support for binding in <code>match</code>​es.  While there is a <a href="https://github.com/ocaml/ocaml/pull/1955">PR for match operators</a> in OCaml it's not clear when it will land.
</p>
</div>
</div>
</div>




<div id="outline-container-orge74edab" class="outline-2">
<h2 id="8">De-duplicating module signatures that depend on abstract data types</h2>
<div class="outline-text-2" id="text-8">
<p>
Archive: <a href="https://discuss.ocaml.org/t/de-duplicating-module-signatures-that-depend-on-abstract-data-types/3826/1">https://discuss.ocaml.org/t/de-duplicating-module-signatures-that-depend-on-abstract-data-types/3826/1</a>
</p>
</div>

<div id="outline-container-org6ae971b" class="outline-3">
<h3 id="org6ae971b">Matt Windsor asked</h3>
<div class="outline-text-3" id="text-org6ae971b">
<p>
In trying to avoid duplicating my <code>module type</code> signatures across <code>ml</code> and <code>mli</code> files, I've ended up using the <code>_intf.ml</code> pattern:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #b22222;">(* </span><span style="color: #b22222;">foo_intf.ml </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">module type</span> <span style="color: #228b22;">Basic</span> = <span style="color: #000000; font-weight: bold;">sig</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">... </span><span style="color: #b22222;">*)</span> <span style="color: #000000; font-weight: bold;">end</span>
<span style="color: #000000; font-weight: bold;">module type</span> <span style="color: #228b22;">S</span> = <span style="color: #000000; font-weight: bold;">sig</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">... </span><span style="color: #b22222;">*)</span> <span style="color: #000000; font-weight: bold;">end</span>

<span style="color: #b22222;">(* </span><span style="color: #b22222;">foo.mli </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">include</span> <span style="color: #000000; font-weight: bold;">module type of</span> <span style="color: #228b22;">Foo_intf</span>
<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Make</span> <span style="color: #a0522d;">(B :</span><span style="color: #228b22;"> Basic</span><span style="color: #a0522d;">) </span>: <span style="color: #228b22;">S</span>

<span style="color: #b22222;">(* </span><span style="color: #b22222;">foo.ml </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">include</span> <span style="color: #228b22;">Foo_intf</span>
<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Make</span> <span style="color: #a0522d;">(B :</span><span style="color: #228b22;"> Basic</span><span style="color: #a0522d;">) </span>: <span style="color: #228b22;">S</span> = <span style="color: #000000; font-weight: bold;">struct</span>
  <span style="color: #b22222;">(* </span><span style="color: #b22222;">... </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
This usually works well (though I'm not sure if there is something more elegant I can do using one of the <code>ppx_import</code> type things).  However, suppose I now want to add a module representing an abstract data type:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #b22222;">(* </span><span style="color: #b22222;">foo.mli </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Config</span> : <span style="color: #000000; font-weight: bold;">sig</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">t</span>
  <span style="color: #b22222;">(* </span><span style="color: #b22222;">... functions ... </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">end</span>

<span style="color: #b22222;">(* </span><span style="color: #b22222;">foo.ml </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Config</span> = <span style="color: #000000; font-weight: bold;">struct</span>
  <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">t</span> = <span style="color: #b22222;">(* </span><span style="color: #b22222;">... </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
If I want to then use <code>Config.t</code> inside the module types I declared in <code>Foo_intf</code>, then I find that I can't easily do so without either:
</p>

<ul class="org-ul">
<li>moving the implementation into <code>foo_intf</code> and either leaving it transparent or restricting the interface I import out of it with an 'expose these in the <code>mli</code>' signature at the end of <code>foo_intf</code>;</li>
<li>adding the type into the <code>Foo.Basic</code> and/or <code>Foo.S</code> module types, then changing <code>Make</code>'s types to add sharing constraints/destructive substitutions to insert <code>Config.t</code>;</li>
<li>declaring <code>Config.t</code> in another file and referring to it from <code>foo_intf</code>.</li>
</ul>

<p>
All of these approaches have fairly unpleasant drawbacks (I lose abstraction, bloat my code with more Weird Module System Things(TM), or have to split up what is conceptually one module just to solve a dependency problem).  Is there anything I'm missing here?
</p>

<p>
(It may very well be that the problem is using <code>_intf.ml</code> in the first place :smile:)
</p>
</div>
</div>


<div id="outline-container-orgcdb51f2" class="outline-3">
<h3 id="orgcdb51f2">Ivan Gotovchits replied</h3>
<div class="outline-text-3" id="text-orgcdb51f2">
<p>
It looks like that you have abstracted your question too much, it is really hard to guess what you are trying to do. Thefore my answer would be a little bit unstructured.
</p>

<p>
There a couple of problems with your approach. It could be because you are misunderstanding some of the concepts in OCaml's module language, or that you are misusing them, and trying to apply modules in the way in which there weren't designed.
</p>

<p>
First of all, I would like to advise against using the <code>include module type of</code> construct. It has very few legit uses, and better should be avoided as it has several drawbacks and caveats. Like, for example, given a <code>module Y : module type of X = X</code>, we don't have type equality between <code>Y.t</code> and <code>X.t</code>. Or even stronger, <code>module type of X</code> refers to types which are different from the types of <code>X</code>.
</p>

<p>
The same is more or less true for the <code>include</code> statement, you shall also use it sparingly. An abstraction that is introduced via <code>include</code> or, worse, <code>include module type of</code> is not an abstraction. Basically, if you want to refer to an abstraction, you shall refer to it directly by its name. If you want to refer to several abstractions, without having to enumerate them all, then instead of using the <code>include</code> statement, you shall create a new abstraction which refers all the abstractions you need directly by name, and then refer to this abstraction by name. Probably, the only legit usage of the <code>include</code> statement is when you're extending an existing abstraction, e.g.,
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module type</span> <span style="color: #228b22;">S</span> = <span style="color: #000000; font-weight: bold;">sig</span>
    <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">t</span>
    <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">init</span> : t
    <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">succ</span> : t -&gt; t
<span style="color: #000000; font-weight: bold;">end</span>

<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Extend</span><span style="color: #a0522d;">(Base :</span><span style="color: #228b22;"> S</span><span style="color: #a0522d;">) </span>: <span style="color: #000000; font-weight: bold;">sig</span>
   <span style="color: #000000; font-weight: bold;">include</span> <span style="color: #228b22;">S</span> <span style="color: #000000; font-weight: bold;">with type</span> <span style="color: #228b22;">t</span> = <span style="color: #228b22;">Base.</span>t
   <span style="color: #000000; font-weight: bold;">val</span> (<span style="color: #0000ff;">+</span>) : t -&gt; t -&gt; t
   <span style="color: #000000; font-weight: bold;">val</span> (<span style="color: #0000ff;">-</span>) : t -&gt; t -&gt; t
   <span style="color: #b22222;">(* </span><span style="color: #b22222;">... </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
Another idea, that you might be missing, is that when you define a signature with an abstract type, e.g.,
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module type</span> <span style="color: #228b22;">S</span> = <span style="color: #000000; font-weight: bold;">sig</span>
   <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">t</span>
   <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">init</span> : t
   <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">succ</span> : t -&gt; t
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
Then every time you reference the signature <code>S</code>, either as a type of a functor parameter or as a module type in your interface, the type <code>S.t</code> will be always different, e.g.,
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">X</span> : <span style="color: #228b22;">S</span>
<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Make</span><span style="color: #a0522d;">(P :</span><span style="color: #228b22;"> S</span><span style="color: #a0522d;">) </span>: <span style="color: #228b22;">S</span>
</pre>
</div>

<p>
In the example above, we have type <code>X.t</code> different from type <code>Make(X).t</code> as well the type <code>P.t</code> of the parameter of the functor <code>Make</code> is different and incompatible from <code>X.t</code> and <code>Make(X).t</code>.
</p>

<p>
If you want to make them equal, you should use manifest types, for that, e.g., to make the functor <code>Make</code> return a module which has type <code>t</code> that is the same type that was passed to it, you have to manifest this,
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Make</span> <span style="color: #a0522d;">(P :</span><span style="color: #228b22;"> Basic</span><span style="color: #a0522d;">) </span>: <span style="color: #228b22;">S</span> <span style="color: #000000; font-weight: bold;">with type</span> <span style="color: #228b22;">t</span> = <span style="color: #228b22;">P.</span>t
</pre>
</div>

<p>
To summarize, when you define an abstract type
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">X</span> : <span style="color: #000000; font-weight: bold;">sig</span>
   <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">t</span>
   <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">init</span> : t
   <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">succ</span> : t -&gt; t
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
You define a structure with a set <code>t</code> and a pair of operations <code>init, succ</code> defined for that set. But when you define a module type
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module type</span> <span style="color: #228b22;">S</span> = <span style="color: #000000; font-weight: bold;">sig</span>
   <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">t</span>
   <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">init</span> : t
   <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">succ</span> : t -&gt; t
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
You define an abstraction of an abstraction, i.e., a set of sets equipped with two operations, <code>init,succ</code>. And therefore, every time you reference an abstraction <code>S</code> you're referencing different sets.
</p>

<p>
Going back to your problem, you shall decide whether your <code>foo</code> module operates with a set of sets abstraction, i.e., it is generic and applicable to any module which implements the <code>Basic</code> interface. Or it is actually specific to a particular abstract type <code>Config.t</code> with a specific interface <code>S</code>. If the latter, then it doesn't make any sense to use a functor. It could be also possible, that you are just missing the sharing constraints in your interface and that is what confuses you.
</p>

<p>
Finally, the <code>_intf.ml</code> idiom should be used very differently. It is usually used, when you have several module types and a functor (or several functors) which operate on those module types, therefore in order to avoid duplication of signatures between the implementation and the signature files, we define a third file with all those module types, and then use those module types (usually with sharing constraints) by names, e.g.,
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #b22222;">(* </span><span style="color: #b22222;">foo_intf.ml </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">module type</span> <span style="color: #228b22;">Basic</span> = <span style="color: #000000; font-weight: bold;">sig</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">... </span><span style="color: #b22222;">*)</span> <span style="color: #000000; font-weight: bold;">end</span>
<span style="color: #000000; font-weight: bold;">module type</span> <span style="color: #228b22;">S</span> = <span style="color: #000000; font-weight: bold;">sig</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">... </span><span style="color: #b22222;">*)</span> <span style="color: #000000; font-weight: bold;">end</span>

<span style="color: #b22222;">(* </span><span style="color: #b22222;">foo.mli </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">open </span><span style="color: #228b22;">Foo_intf</span>
<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Make</span> <span style="color: #a0522d;">(Input :</span><span style="color: #228b22;"> Basic</span><span style="color: #a0522d;">)  </span>: <span style="color: #228b22;">S</span> <span style="color: #000000; font-weight: bold;">with type</span> <span style="color: #228b22;">t</span> := <span style="color: #228b22;">Input.</span><span style="color: #000000; background-color: #ffffff;">S</span>

<span style="color: #b22222;">(* </span><span style="color: #b22222;">foo.ml </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">open </span><span style="color: #228b22;">Foo_intf</span>
<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Make</span> <span style="color: #a0522d;">(B :</span><span style="color: #228b22;"> Basic</span><span style="color: #a0522d;">) </span>: <span style="color: #228b22;">S</span> = <span style="color: #000000; font-weight: bold;">struct</span>
  <span style="color: #b22222;">(* </span><span style="color: #b22222;">... </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
On rare occasions, when it is nearly impossible to avoid this, we will do
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #b22222;">(* </span><span style="color: #b22222;">foo.mli </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">include</span> <span style="color: #228b22;">Foo_intf.S</span>
</pre>
</div>

<p>
You might see the code like this in Core, but you shouldn't repeat this approach in your code. Not because it is bad, but because it is very specific to Janestreet Core library history and OCaml history.
</p>
</div>
</div>
</div>




<div id="outline-container-orgd9fd80a" class="outline-2">
<h2 id="9">Other OCaml News</h2>
<div class="outline-text-2" id="text-9">
</div>
<div id="outline-container-orgc040c25" class="outline-3">
<h3 id="orgc040c25">From the ocamlcore planet blog</h3>
<div class="outline-text-3" id="text-orgc040c25">
<p>
Here are links from many OCaml blogs aggregated at <a href="http://ocaml.org/community/planet/">OCaml Planet</a>.
</p>

<ul class="org-ul">
<li><a href="https://coq.inria.fr/news/coq-891-is-out.html">Coq 8.9.1 is out</a></li>
<li><a href="https://coq.inria.fr/news/coq-8-10beta1-is-out.html">Coq 8.10+beta1 is out</a></li>
</ul>
</div>
</div>
</div>




<div id="outline-container-org94efb58" class="outline-2">
<h2 id="org94efb58">Old CWN</h2>
<div class="outline-text-2" id="text-org94efb58">
<p>
If you happen to miss a CWN, you can <a href="mailto:alan.schmitt@polytechnique.org">send me a message</a> and I'll mail it to you, or go take a look at <a href="http://alan.petitepomme.net/cwn/">the archive</a> or the <a href="http://alan.petitepomme.net/cwn/cwn.rss">RSS feed of the archives</a>.
</p>

<p>
If you also wish to receive it every week by mail, you may subscribe <a href="http://lists.idyll.org/listinfo/caml-news-weekly/">online</a>.
</p>

<div class="authorname">
<p>
<a href="http://alan.petitepomme.net/">Alan Schmitt</a>
</p>

</div>
</div>
</div>
</div>
</body>
</html>
