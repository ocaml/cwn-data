<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-07-28 Tue 18:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OCaml Weekly News</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style type="text/css">#table-of-contents h2 { display: none } .title { display: none } .authorname { text-align: right }</style>
<style type="text/css">.outline-2 {border-top: 1px solid black;}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">OCaml Weekly News</h1>
<p>
<a href="http://alan.petitepomme.net/cwn/2020.07.21.html">Previous Week</a> <a href="http://alan.petitepomme.net/cwn/index.html">Up</a> <a href="http://alan.petitepomme.net/cwn/2020.08.11.html">Next Week</a>
</p>

<p>
Hello
</p>

<p>
Here is the latest OCaml Weekly News, for the week of July 21 to 28, 2020.
</p>

<p>
As I will be away with no internet next week, the next CWN will be on August 11.
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#1">Embedded ocaml templates</a></li>
<li><a href="#2">Proposal: Another way to debug memory leaks</a></li>
<li><a href="#3">Camlp5 (8.00~alpha01) and pa_ppx (0.01)</a></li>
<li><a href="#4">OCaml 4.11.0, third (and last?) beta release</a></li>
<li><a href="#5">Other OCaml News</a></li>
<li><a href="#orge9bc676">Old CWN</a></li>
</ul>
</div>
</div>


<div id="outline-container-orgacdef29" class="outline-2">
<h2 id="1"><a id="orgacdef29"></a>Embedded ocaml templates</h2>
<div class="outline-text-2" id="text-1">
<p>
Archive: <a href="https://discuss.ocaml.org/t/embedded-ocaml-templates/6124/1">https://discuss.ocaml.org/t/embedded-ocaml-templates/6124/1</a>
</p>
</div>

<div id="outline-container-org6ca736a" class="outline-3">
<h3 id="org6ca736a">Emile Trotignon announced</h3>
<div class="outline-text-3" id="text-org6ca736a">
<p>
I am very happy to announce the release of ocaml-embedded-templates.
</p>

<p>
This is a tool similar to camlmix, but camlmix was not updated for 7 years, and there is no easy way to
handle a lot of templates (my command takes a directory as an argument and generate an ocaml module by
going through the directory recursively)
I also choosed to use a syntax similar to EJS, and there is a ppx for inline EML.
</p>

<p>
You can check it out here : <a href="https://github.com/EmileTrotignon/embedded_ocaml_templates">https://github.com/EmileTrotignon/embedded_ocaml_templates</a>
</p>

<p>
Here is a more extensive exemple of what can be done with this :
<a href="https://github.com/EmileTrotignon/resume_of_ocaml">https://github.com/EmileTrotignon/resume_of_ocaml</a> (This project generate my resume/website in both
latex and html).
</p>

<p>
This is my first opam package : feedback is very much welcome.
</p>
</div>
</div>
</div>




<div id="outline-container-org83caa6f" class="outline-2">
<h2 id="2"><a id="org83caa6f"></a>Proposal: Another way to debug memory leaks</h2>
<div class="outline-text-2" id="text-2">
<p>
Archive: <a href="https://discuss.ocaml.org/t/proposal-another-way-to-debug-memory-leaks/6134/1">https://discuss.ocaml.org/t/proposal-another-way-to-debug-memory-leaks/6134/1</a>
</p>
</div>

<div id="outline-container-org69712f3" class="outline-3">
<h3 id="org69712f3">Jim Fehrle said</h3>
<div class="outline-text-3" id="text-org69712f3">
<p>
<code>memprof</code> helps you discover where memory was allocated, which is certainly useful.  However, that may
not be enough information to isolate a leak.  Sometimes you'd like to know what variables refer to
excessive amounts of memory.
</p>

<p>
For this, you'd want to examine all the garbage collection roots and report how much memory is used by
each.  This is useful information if you can map a GC root back to a source file and variable.
</p>

<p>
I prototyped code to do that to help with Coq bug <a href="https://github.com/coq/coq/issues/12487">https://github.com/coq/coq/issues/12487</a>.  It
localized several leaks enough across over 500 source files so that we could find and fix them.  But my
prototype code is a bit crude.  I'd like to clean it up and submit it as a PR.  Since this could be
done in various ways, I wanted to get some design/API feedback up front rather than maybe doing some of
it twice.  Also I'd like to confident that such a PR would be accepted and merged in a reasonable
amount of time&#x2013;otherwise why bother.
</p>

<p>
<a href="https://github.com/ocaml/ocaml/blob/80326033cbedfe59c0664e3912f21017e968a1e5/runtime/roots_nat.c#L399">caml_do_roots</a>
shows how to access the GC roots.  There are several types of roots:
</p>
<ul class="org-ul">
<li>global roots, corresponding to top-level variables in source files</li>
<li>dynamic global roots</li>
<li>stack and local roots</li>
<li>global C roots</li>
<li>finalized values</li>
<li>memprof</li>
<li>hook</li>
</ul>

<p>
<b>API (in Gc):</b>
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">print_global_reachable</span> : out_channel -&gt; int -&gt; unit
</pre>
</div>

<p>
Prints a list to <code>out_channel</code> of the global roots that reach more than the specified number of words.
Each item shows the number of reachable words, the associated index of the root in the <code>*glob</code> for that
file and the name of the source file.
</p>

<p>
Something like this (but with only filenames rather than pathnames):
</p>

<pre class="example">
  102678 field  17 plugins/ltac/pltac.ml
  102730 field  18 plugins/ltac/pltac.ml
  164824 field  20 plugins/ltac/tacenv.ml
 1542857 field  26 plugins/ltac/tacenv.ml
35253743 field  65 stm/stm.ml
35201913 field   8 vernac/vernacstate.ml
 8991864 field  24 vernac/library.ml
  112035 field   8 vernac/egramml.ml
 6145454 field  84 vernac/declaremods.ml
 6435878 field  89 vernac/declaremods.ml
</pre>

<p>
I would use ELF information in the binary file to map from <code>*glob</code> back to a filename.  For example,
the address symbol of the entry <code>camlTest</code> corresponds to <code>test.ml</code>.  This would only work for binary
executables compiled with the <code>-g</code> option.  It wouldn't work for byte-compiled code.  It would print an
error message if it's not ELF or not <code>-g</code>.  Also, being a little lazy, how essential is it to support
32-bit binaries?  (Q: What happens if you have 2 source files with the same name though in different
directories?  Would the symbol table distinguish them?)
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">get_field_index</span> : <span style="color: #228b22;">Obj.</span>t -&gt; int
</pre>
</div>

<p>
Returns the <code>*glob</code> index number for the top-level variable (passed as <code>Obj.repr var</code>).  I expect
there's no way to recover variable names from the <code>*glob</code> index.  In my experiments, it appeared that
the entries in <code>*glob</code> were in the same order as as the variable and function declarations.  This would
let a developer do a binary search in the code to locate the variable which it probably a necessity for
large, complex files such as Coq's <code>stm.ml</code>&#x2013;3300 lines, 10+ modules defined within the file.  (I
noticed that variables defined in modules defined within the source file were not in <code>*glob</code>.  I expect
there is a root for the module as a whole and that those variables can be readily found within that
root.)
</p>

<p>
This would need an extended explanation in <code>gc.mli</code>.
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">print_stack_reachable</span> : out_channel -&gt; int -&gt; unit
</pre>
</div>

<p>
Prints a backtrace to <code>out_channel</code> that also shows which roots for each frame reach more than the
specified number of words.  (I'd keep the "item numbers" since there's no way to translate them to
variables and they might give some clues.)
</p>

<pre class="example">
Called from file "tactics/redexpr.ml" (inlined), line 207, characters 29-40
 356758154 item    0 (stack)
Called from file "plugins/ltac/tacinterp.ml", line 752, characters 6-51
  17646719 item    0 (stack)
    119041 item    1 (stack)
Called from file "engine/logic_monad.ml", line 195, characters 38-43
    119130 item    0 (stack)
 373378237 item    1 (stack)
</pre>

<p>
As it turns out, 90% of the memory in Coq issue mentioned above is reachable only from the stack.
</p>

<p>
I didn't consider the other types of roots yet, which I don't fully understand, such as local roots.
Just covering global and stack roots seems like a good contribution.  Dynamic global roots may be easy
to add if they are otherwise similar to global roots.  For the others I could print the reachable
words, but I don't know how to direct the developer to look at the relevant part of the code,
especially if it's in C code.  I suppose <code>print_global_reachable</code> and <code>print_stack_reachable</code> could be
a single routine as well.  That's probably better.
</p>

<p>
Let me know your thoughts.
</p>
</div>
</div>
</div>




<div id="outline-container-orgb9c5555" class="outline-2">
<h2 id="3"><a id="orgb9c5555"></a>Camlp5 (8.00~alpha01) and pa_ppx (0.01)</h2>
<div class="outline-text-2" id="text-3">
<p>
Archive: <a href="https://discuss.ocaml.org/t/ann-camlp5-8-00-alpha01-and-pa-ppx-0-01/6144/1">https://discuss.ocaml.org/t/ann-camlp5-8-00-alpha01-and-pa-ppx-0-01/6144/1</a>
</p>
</div>

<div id="outline-container-orgdf4f651" class="outline-3">
<h3 id="orgdf4f651">Chet Murthy announced</h3>
<div class="outline-text-3" id="text-orgdf4f651">
</div>
<div id="outline-container-org1e9a280" class="outline-4">
<h4 id="org1e9a280"><code>Camlp5 (8.00~alpha01)</code> and <code>pa_ppx (0.01)</code></h4>
<div class="outline-text-4" id="text-org1e9a280">
<p>
I'm pleased to announce the release of two related projects:
</p>

<ol class="org-ol">
<li><a href="https://github.com/camlp5/camlp5">Camlp5</a>: version 8.00~alpha01 is an alpha release of Camlp5, with full support for OCaml syntax up to version 4.10.0, as well as minimal compatibility with version 4.11.0. In particular there is full support for PPX attributes and extensions.</li>

<li><a href="https://github.com/chetmurthy/pa_ppx">pa_ppx</a>: version 0.01 is a re-implementation of a large number of PPX rewriters (e.g. ppx_deriving (std (show, eq, map, etc), yojson, sexp, etc), ppx_import, ppx_assert, others) on top of Camlp5, along with an infrastructure for developing new ones.</li>
</ol>

<p>
This allows projects to combine the existing style of Camlp5 syntax
extension, with PPX rewriting, without having to jump thru hoops to
invoke camlp5 on some files, and PPX processors on others.
</p>

<p>
Camlp5 alone is not compatible with existing PPX rewriters: Camlp5
syntax-extensions (e.g. "stream parsers") would be rejected by the
OCaml parser, and PPX extensions/attributes are ignored by Camlp5
(again, without <code>pa_ppx</code>).  <code>pa_ppx</code> provides Camlp5-compatible
versions of many existing PPX rewriters, as well as new ones, so that
one can use Camlp5 syntax extensions as well as PPX rewriters.  In
addition, some of the re-implemented rewriters are more-powerful than
their original namesakes, and there are new ones that add interesting
functionality.
</p>
</div>
</div>

<div id="outline-container-org3794b49" class="outline-4">
<h4 id="org3794b49">For democratizing macro-extension-authoring in OCaml</h4>
<div class="outline-text-4" id="text-org3794b49">
<p>
TL;DR Writing OCaml PPX rewriters is <b>hard work</b>.  There is a
complicated infrastructure that is hard to explain, there are multiple
such incompatible infrastructures (maybe these are merging?) and it is
hard enough that most Ocaml programmers do not write macro-extensions
as a part of their projects.  I believe that using Camlp5 and pa_ppx
can make it easier to write macro-extensions, via:
</p>

<ol class="org-ol">
<li>providing a simple way of thinking about adding your extension to the parsing process.</li>

<li>providing transparent tools (e.g. quotations) for pattern-matching/constructing AST fragments</li>
</ol>

<p>
Explained below in [Macro Extensions with Pa_ppx](#macro-extensions-with-pa_ppx).
</p>
</div>

<ul class="org-ul">
<li><a id="orgf300fd4"></a>The original arguments against Camlp4<br />
<div class="outline-text-5" id="text-orgf300fd4">
<p>
The original argument against using Camlp4 as a basis for
macro-preprocessing in Ocaml, had several points (I can't find the
original document, but from memory):
</p>

<ol class="org-ol">
<li><b>syntax-extension</b> as the basis of macro-extension leads to brittle syntax: multiple syntax extensions often do not combine well.</li>

<li>a different AST type than the Ocaml AST</li>

<li>a different parsing/pretty-printing infrastructure, which must be maintained alongside of Ocaml's own parser/pretty-printer.</li>

<li>A new and complicated set of APIs are required to write syntax extensions.</li>
</ol>

<p>
To this, I'll add
</p>

<ol class="org-ol">
<li>Camlp4 was <b>forked</b> from Camlp5, things were changed, and hence, Camlp4 lost the contribution of its original author.  Hence, maintaining Camlp4 was always labor that fell on the Ocaml team. [Maybe this doesn't matter, but it counts for something.]</li>
</ol>
</div>
</li>

<li><a id="org1687427"></a>Assessing the arguments, with some hindsight<br />
<div class="outline-text-5" id="text-org1687427">
<ol class="org-ol">
<li><p>
<b>syntax-extension</b> as the basis of macro-extension leads to brittle syntax: multiple syntax extensions often do not combine well.
</p>

<p>
In retrospect, this is quite valid: even if one prefers and enjoys
LL(1) grammars and parsing, when multiple authors write
grammar-extensions which are only combined by third-party projects,
the conditions are perfect for chaos, and of a sort that
project-authors simply shouldn't have to sort out.  And this chaos is
of a different form, than merely having two PPX rewriters use the same
attribute/extension-names (which is, arguably, easily detectable with
some straightforward predeclaration).
</p></li>

<li><p>
Camlp4/5 has a different AST type than the Ocaml AST
</p>

<p>
Over time, the PPX authors themselves have slowly started to conclude
that the current reliance on the Ocaml AST is fraught with problems.
The "Future of PPX" discussion thread talks about using something like
s-expressions, and more generally about a more-flexible AST type.
</p></li>

<li><p>
a different parsing/pretty-printing infrastructure, which must be maintained alongside of Ocaml's own parser/pretty-printer.
</p>

<p>
A different AST type necessarily means a different
parser/pretty-printer.  Of course, one could modify Ocaml's YACC
parser to produce Camlp5 ASTs, but this is a minor point.
</p></li>

<li><p>
A new and complicated set of APIs are required to write syntax extensions.
</p>

<p>
With time, it's clear that PPX has produced the same thing.
</p></li>

<li><p>
Maintaining Camlp4 was always labor that fell on the Ocaml team.
</p>

<p>
The same argument (that each change to the Ocaml AST requires work to
update Camlp5) can be made for PPX (specifically, this is the raison
d'etre of ocaml-migrate-parsetree).  Amusingly, one could imagine
using ocaml-migrate-parsetree as the basis for making Camlp5
OCaml-version-independent, too.  That is, the "backend" of Camlp5
could use ocaml-migrate-parsetree to produce ASTs for a version of
OCaml different from the one on which it was compiled.
</p></li>
</ol>
</div>
</li>
</ul>
</div>

<div id="outline-container-org0a525df" class="outline-4">
<h4 id="org0a525df">Arguments against the current API(s) of PPX rewriting</h4>
<div class="outline-text-4" id="text-org0a525df">
<p>
The overall argument is that it's too complicated for most OCaml
programmers to write their own extensions; what we see instead of a
healthy ecosystem of many authors writing and helping-improve PPX
rewriters, is a small number of rewriters, mostly written by Jane
Street and perhaps one or two other shops.  There are a few big
reasons why this is the case (which correspond to the responses
above), but one that isn't mentioned is:
</p>

<ol class="org-ol">
<li>When the "extra data" of a PPX extension or attribute is easily-expressed with the fixed syntax of PPX payloads, all is <code>~well~</code> ok, but certainly not in great shape.  Here's an example:</li>
</ol>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">package_type</span> =
<span style="color: #483d8b; background-color: #ebebeb;">[%import</span>: <span style="color: #228b22;">Parsetree.</span>package_type
          <span style="color: #483d8b;">[@with core_type    := Parsetree.core_type [@printer Pprintast.core_type];</span>
<span style="color: #483d8b;">                 Asttypes.loc := Asttypes.loc [@polyprinter fun pp fmt x -&gt; pp fmt x.Asttypes.txt];</span>
<span style="color: #483d8b;">                 Longident.t  := Longident.t [@printer pp_longident]]</span><span style="color: #483d8b; background-color: #ebebeb;">]</span>
<span style="color: #483d8b;">[@@deriving show]</span>
</pre>
</div>

<p>
The expression-syntax of assignment is used to express type-expression
rewrites.  And this is necesarily limited, because we cannot (for
example) specify left-hand-sizes that are type-expressions with
variables.  It's a perversion of the syntax, when what we really want
to have is something that is precise: "map this type-expression to
that type-expression".
</p>

<p>
Now, with the new Ocaml 4.11.0 syntax, there's a (partial) solution:
use "raw-string-extensions" like <code>{%foo|argle|}</code>.  This is the same as
<code>[%foo {|argle|}]</code>.  This relies on the PPX extension to parse the
payload.  But there are problems:
</p>

<ol class="org-ol">
<li>Of course, there's no equivalent <code>{@foo|argle|}</code> (and "@@", "@@@" of course) for attributes.</li>

<li>If the payload in that string doesn't <b>itself</b> correspond to some parseable Ocaml AST type, then again, we're stuck: we have to cobble together a parser instead of being able to merely extend the parser of Ocaml to deal with the case.</li>
</ol>

<p>
Note well that I'm not saying that we should extend the parsing rules
of the Ocaml language.  Rather, that with an <b>extensible parser</b>
(hence, LL(1)) we can add new nonterminals, add rules that reference
existing nonterminals, and thereby get an exact syntax (e.g.) for the
<code>ppx_import</code> example above.  That new nonterminal is used <b>only</b> in
parsing the payload &#x2013; nowhere else &#x2013; so we haven't introduced
examples of objection #1 above.
</p>

<p>
And it's not even very hard.
</p>
</div>
</div>

<div id="outline-container-org810fab2" class="outline-4">
<h4 id="org810fab2">Macro Extensions with Pa_ppx</h4>
<div class="outline-text-4" id="text-org810fab2">
<p>
The basic thesis of <code>pa_ppx</code> is "let's not throw the baby out with the
bathwater".  Camlp5 has a lot of very valuable infrastructure that can
be used to make writing macro-preprocessors much easier.  <code>pa_ppx</code>
adds a few more.
</p>

<ol class="org-ol">
<li>Quotations for patterns and expressions over all important OCaml AST types.</li>

<li>"extensible functions" to make the process of recursing down the AST transparent, and the meaning of adding code to that process equally transparent.</li>

<li><code>pa_ppx</code> introduces "passes" and allows each extension to register which other extensions it must follow, and which may follow it; then <code>pa_ppx</code> topologically sorts them, so there's no need for project-authors to figure out how to order their PPX extension invocations.</li>
</ol>

<p>
As an example of a PPX rewriter based on <code>pa_ppx</code>, here's
<a href="https://pa-ppx.readthedocs.io/en/latest/tutorial.html#an-example-ppx-rewriter-based-on-pa-ppx">pa_ppx.here</a>
from the <code>pa_ppx</code> tutorial.  In that example, you'll see that Camlp5
infrastructure is used to make things easy:
</p>

<ol class="org-ol">
<li>quotations are used to both build the output AST fragment, and to pattern-match on inputs.</li>

<li>the "extensible functions" are used to add our little bit of rewriter to the top-down recursion.</li>

<li>and we declare our rewriter to the infrastructure (we don't specify what passes it must come before or after, since <code>pa_ppx.here</code> is so simple).</li>
</ol>
</div>
</div>

<div id="outline-container-org2aaa999" class="outline-4">
<h4 id="org2aaa999">Conclusion</h4>
<div class="outline-text-4" id="text-org2aaa999">
<p>
I'm not trying to convince you to switch away from PPX to Camlp5.
Perhaps, I'm not even merely arguing that you should use <code>pa_ppx</code> and
author new macro-extensions on it.  But I <b>am</b> arguing that the features of
</p>

<ol class="org-ol">
<li>quotations, with antiquotations in as many places as possible, and hence, <b>in places where Ocaml identifiers are not permitted</b>.</li>

<li>facilities like "extensible functions", with syntax support for them</li>

<li>a new AST type, that is suitable for macro-preprocessing, but isn't merely "s-expressions" (after all, there's a reason we all use strongly-typed languages)</li>

<li>an extensible parser for the Ocaml language, usable in PPX attribute/extension payloads</li>
</ol>

<p>
are important and valuable, and a PPX rewriter infrastructure that
makes it possible for the masses to write their own macro-extensions,
is going to incorporate these things.
</p>
</div>
</div>
</div>
</div>




<div id="outline-container-org9f7349e" class="outline-2">
<h2 id="4"><a id="org9f7349e"></a>OCaml 4.11.0, third (and last?) beta release</h2>
<div class="outline-text-2" id="text-4">
<p>
Archive: <a href="https://discuss.ocaml.org/t/ocaml-4-11-0-third-and-last-beta-release/6149/1">https://discuss.ocaml.org/t/ocaml-4-11-0-third-and-last-beta-release/6149/1</a>
</p>
</div>

<div id="outline-container-org3f3ac0d" class="outline-3">
<h3 id="org3f3ac0d">octachron announced</h3>
<div class="outline-text-3" id="text-org3f3ac0d">
<p>
The release of OCaml 4.11.0 is near.
As one step further in this direction, we have published a third
and potentially last beta release.
</p>

<p>
This new release fixes an infrequent best-fit allocator bug and an issue
with floating-point software emulation in the ARM EABI port.
On the ecosystem side, merlin is now available for this new version of OCaml.
The compatibility of the opam ecosystem with OCaml 4.11.0 is currently
good, and it should be possible to test this beta without too much trouble.
</p>

<p>
The source code is available at these addresses:
</p>

<p>
<a href="https://github.com/ocaml/ocaml/archive/4.11.0+beta3.tar.gz">https://github.com/ocaml/ocaml/archive/4.11.0+beta3.tar.gz</a> <br />
<a href="https://caml.inria.fr/pub/distrib/ocaml-4.11/ocaml-4.11.0+beta3.tar.gz">https://caml.inria.fr/pub/distrib/ocaml-4.11/ocaml-4.11.0+beta3.tar.gz</a>
</p>

<p>
The compiler can also be installed as an OPAM switch with one of the
following commands:
</p>
<div class="org-src-container">
<pre class="src src-shell">opam update
opam switch create ocaml-variants.4.11.0+beta3 --repositories=default,<span style="color: #a0522d;">beta</span>=git+https://github.com/ocaml/ocaml-beta-repository.git
</pre>
</div>
<p>
or
</p>
<div class="org-src-container">
<pre class="src src-shell">opam update
opam switch create ocaml-variants.4.11.0+beta3+VARIANT --repositories=default,<span style="color: #a0522d;">beta</span>=git+https://github.com/ocaml/ocaml-beta-repository.git
</pre>
</div>
<p>
where you replace VARIANT with one of these: afl, flambda, fp, fp+flambda
</p>

<p>
We would love to hear about any bugs. Please report them here:
 <a href="https://github.com/ocaml/ocaml/issues">https://github.com/ocaml/ocaml/issues</a>
</p>

<p>
Compared to the previous beta release, the exhaustive list of changes
is as follows:
</p>
</div>

<div id="outline-container-org9e4e5b9" class="outline-4">
<h4 id="org9e4e5b9">Runtime:</h4>
<div class="outline-text-4" id="text-org9e4e5b9">
<ul class="org-ul">
<li><a href="https://github.com/ocaml/ocaml/issues/9736">#9736</a>, <a href="https://github.com/ocaml/ocaml/issues/9749">#9749</a>: Compaction must start in a heap where all free blocks are blue, which was not the case with the best-fit allocator. (Damien Doligez, report and review by Leo White)</li>

<li>+ [*new bug fixes*] <a href="https://github.com/ocaml/ocaml/issues/9316">#9316</a>, <a href="https://github.com/ocaml/ocaml/issues/9443">#9443</a>, <a href="https://github.com/ocaml/ocaml/issues/9463">#9463</a>, <a href="https://github.com/ocaml/ocaml/issues/9782">#9782</a>: Use typing information from Clambda or mutable Cmm variables. (Stephen Dolan, review by Vincent Laviron, Guillaume Bury, Xavier Leroy, and Gabriel Scherer; temporary bug report by Richard Jones)</li>
</ul>
</div>
</div>

<div id="outline-container-orgdb9cba2" class="outline-4">
<h4 id="orgdb9cba2">Manual and documentation:</h4>
<div class="outline-text-4" id="text-orgdb9cba2">
<ul class="org-ul">
<li><a href="https://github.com/ocaml/ocaml/issues/9541">#9541</a>: Add a documentation page for the instrumented runtime; additional changes to option names in the instrumented runtime. (Enguerrand Decorne, review by Anil Madhavapeddy, Gabriel Scherer, Daniel Bünzli, David Allsopp, Florian Angeletti, and Sébastien Hinderer)</li>
</ul>

<p>
Entries marked with "+" were already present in previous alphas, but
they have been complemented by new bug fixes.
</p>

<p>
If you are interested by the list of new features, and the nearly final list
of bug fixes the updated change log for OCaml 4.11.0 is available at:
</p>

<p>
<a href="https://github.com/ocaml/ocaml/blob/4.11/Changes">https://github.com/ocaml/ocaml/blob/4.11/Changes</a>
</p>
</div>
</div>
</div>
</div>




<div id="outline-container-org477bf6b" class="outline-2">
<h2 id="5"><a id="org477bf6b"></a>Other OCaml News</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org97dbaac" class="outline-3">
<h3 id="org97dbaac">From the ocamlcore planet blog</h3>
<div class="outline-text-3" id="text-org97dbaac">
<p>
Here are links from many OCaml blogs aggregated at <a href="http://ocaml.org/community/planet/">OCaml Planet</a>.
</p>

<ul class="org-ul">
<li><a href="http://frama-c.com/index.html">Frama-Clang 0.0.9 is out. Download it here.</a></li>
</ul>
</div>
</div>
</div>




<div id="outline-container-orge9bc676" class="outline-2">
<h2 id="orge9bc676">Old CWN</h2>
<div class="outline-text-2" id="text-orge9bc676">
<p>
If you happen to miss a CWN, you can <a href="mailto:alan.schmitt@polytechnique.org">send me a message</a> and I'll mail it to you, or go take a look at <a href="http://alan.petitepomme.net/cwn/">the archive</a> or the <a href="http://alan.petitepomme.net/cwn/cwn.rss">RSS feed of the archives</a>.
</p>

<p>
If you also wish to receive it every week by mail, you may subscribe <a href="http://lists.idyll.org/listinfo/caml-news-weekly/">online</a>.
</p>

<div class="authorname">
<p>
<a href="http://alan.petitepomme.net/">Alan Schmitt</a>
</p>

</div>
</div>
</div>
</div>
</body>
</html>
