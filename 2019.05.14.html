<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2019-05-14 Tue 09:03 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>OCaml Weekly News</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<style type="text/css">#table-of-contents h2 { display: none } .title { display: none } .authorname { text-align: right }</style>
<style type="text/css">.outline-2 {border-top: 1px solid black;}</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">OCaml Weekly News</h1>
<p>
<a href="http://alan.petitepomme.net/cwn/2019.05.07.html">Previous Week</a> <a href="http://alan.petitepomme.net/cwn/index.html">Up</a> <a href="http://alan.petitepomme.net/cwn/2019.05.21.html">Next Week</a>
</p>

<p>
Hello
</p>

<p>
Here is the latest OCaml Weekly News, for the week of May 07 to 14, 2019.
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#1">Bimap (bi-directional map) implementation</a></li>
<li><a href="#2">Modules that extend modules from third-party packages</a></li>
<li><a href="#3">PSA: dns 2.0 &#x2013; a new udns era dawns</a></li>
<li><a href="#4">Next OUPS meetup May 21st 2019</a></li>
<li><a href="#5">Other OCaml News</a></li>
<li><a href="#org48d6f79">Old CWN</a></li>
</ul>
</div>
</div>


<div id="outline-container-orga1e3d11" class="outline-2">
<h2 id="1">Bimap (bi-directional map) implementation</h2>
<div class="outline-text-2" id="text-1">
<p>
Archive: <a href="https://discuss.ocaml.org/t/bimap-bi-directional-map-implementation/3776/1">https://discuss.ocaml.org/t/bimap-bi-directional-map-implementation/3776/1</a>
</p>
</div>

<div id="outline-container-orgbe589e2" class="outline-3">
<h3 id="orgbe589e2">paul announced</h3>
<div class="outline-text-3" id="text-orgbe589e2">
<p>
An implementation of a bimap, a map that is bi-directional and which any client code can use to look up keys if given values as well as traditional lookup of values given keys. Implemented using functors as a class and a module, with support for multi-maps as well as well as single-valued maps. Master branch uses Core. A no-core branch is a work-in-progress and needs re-writing. OUnit testing also implemented.
</p>

<p>
<a href="https://github.com/pat227/bimap.git">https://github.com/pat227/bimap.git</a>
</p>
</div>
</div>
</div>




<div id="outline-container-orge6384d2" class="outline-2">
<h2 id="2">Modules that extend modules from third-party packages</h2>
<div class="outline-text-2" id="text-2">
<p>
Archive: <a href="https://discuss.ocaml.org/t/modules-that-extend-modules-from-third-party-packages/3777/1">https://discuss.ocaml.org/t/modules-that-extend-modules-from-third-party-packages/3777/1</a>
</p>
</div>

<div id="outline-container-orgb52cad5" class="outline-3">
<h3 id="orgb52cad5">Matt Windsor asked</h3>
<div class="outline-text-3" id="text-orgb52cad5">
<p>
What is the recommended way to structure modules that add extensions onto other modules that come from external packages (over which you have no control)?
</p>

<p>
How do you then structure those modules so that they can themselves be extended, and/or that the extensions can be taken out separately and, say, applied on top of <span class="underline">other</span> extensions or modifications to those libraries (say, if I target <code>Base</code>, being able to apply the extensions to <code>Core_kernel</code>)
</p>

<p>
Currently I'm doing something like this, where I want to add things to a module in <code>Base</code>:
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #b22222;">(* </span><span style="color: #b22222;">base_exts/bar.mli </span><span style="color: #b22222;">*)</span>

<span style="color: #000000; font-weight: bold;">include</span> <span style="color: #000000; font-weight: bold;">module type of</span> <span style="color: #228b22;">Base.Bar</span>
<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Extensions</span> : <span style="color: #000000; font-weight: bold;">sig</span>
  <span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">foo</span> : t -&gt; <span style="color: #228b22;">Something.</span>t -&gt; <span style="color: #228b22;">Something_else.</span>t -&gt; t <span style="color: #228b22;">Base.Or_error.</span>t
<span style="color: #000000; font-weight: bold;">end</span>
<span style="color: #000000; font-weight: bold;">include</span> <span style="color: #000000; font-weight: bold;">module type of</span> <span style="color: #228b22;">Extensions</span>

<span style="color: #b22222;">(* </span><span style="color: #b22222;">base_exts/bar.ml </span><span style="color: #b22222;">*)</span>

<span style="color: #000000; font-weight: bold;">include</span> <span style="color: #228b22;">Base.Bar</span> <span style="color: #b22222;">(* </span><span style="color: #b22222;">[!] </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">Extensions</span> = <span style="color: #000000; font-weight: bold;">struct</span>
  <span style="color: #000000; font-weight: bold;">let</span> <span style="color: #0000ff;">foo</span> (<span style="color: #a0522d;">bar</span>:<span style="color: #228b22;"> t</span>) (<span style="color: #a0522d;">baz</span>:<span style="color: #228b22;"> Something.t</span>) (<span style="color: #a0522d;">barbaz</span>:<span style="color: #228b22;"> Something_else.t</span>)
    : t <span style="color: #228b22;">Base.Or_error.</span>t = <span style="color: #b22222;">(* </span><span style="color: #b22222;">do something </span><span style="color: #b22222;">*)</span>
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
If I then want to re-apply the same extensions to the <code>Core_kernel</code> version of <code>baz</code>, I'll just import <code>Base_exts.Bar.Extensions</code> over an include of <code>Core_kernel.Bar</code>.  The extensions still depend on the <code>Base</code> implementation of everything, but that shouldn't matter as long as the <code>t</code> agrees?
</p>

<p>
It occurs to me (after trying to publish an opam package with this setup, natch) that this might be a <b>Very Bad Idea</b>:
</p>

<ul class="org-ul">
<li>That include may <span class="underline">very well</span> be copying the whole body of <code>Base.Bar</code> into my module.  (I'm not sure how includes work, but that'd be the most semantically obvious thing to do.)  I definitely don't want to be distributing half of, say, Jane Street's libraries in my opam packages, for obvious infrastructural and legal reasons!  I've seen parts of <code>Core_kernel</code> include parts of <code>Base</code> like this, but it may be that, since they're two parts of the same library family, this is OK to do in that situation.</li>
<li><code>odoc</code> seems to be picking up the entire API surface of <code>Base.Bar</code> when I do the above.  This certainly isn't what I want—I want to be loosely saying 're-export everything that <code>Base.Bar</code> exports', <span class="underline">not</span> 're-export this specific thing and this specific thing and then this specific thing', <span class="underline">especially</span> since the latter ties the documentation to a specific version of the external library.</li>
</ul>

<p>
So far I've seen two other approaches:
</p>

<ol class="org-ol">
<li>Don't re-export anything, just provide extensions to be used as a separate module alongside the original one.  This is what I used to do, and what I think <code>Core_extended</code> and its various spinoff libraries do?, but I got sick of having to remember which function was in <code>Base.Bar</code> and which was in <code>Base_exts.My_bar</code>.  In hindsight this was probably an acceptable compromise (and avoids having to remember which things are in the other library and which are the extensions), and I might revert back to it.</li>
<li><p>
<code>Core_kernel</code> sometimes includes <code>Base</code> modules in the form
</p>
<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">t</span> = <span style="color: #228b22;">Base.Foo.</span>t <span style="color: #483d8b;">[@@deriving stuff]</span>
<span style="color: #000000; font-weight: bold;">include</span> <span style="color: #228b22;">(Base.Foo : (</span><span style="color: #000000; font-weight: bold;">module type of</span><span style="color: #228b22;"> </span><span style="color: #000000; font-weight: bold;">struct</span><span style="color: #228b22;"> include Base.Foo </span><span style="color: #000000; font-weight: bold;">end</span><span style="color: #228b22;"> </span><span style="color: #000000; font-weight: bold;">with type</span><span style="color: #228b22;"> </span><span style="color: #228b22;">t</span><span style="color: #228b22;"> := t))</span>
</pre>
</div>
<p>
I'm not sure whether the indirection of hiding <code>Base.Foo</code>'s type inside another module type has any purpose other than enabling the re-declaration of <code>t</code>, but, if so, is this relevant to what I'm looking at?
</p></li>
</ol>

<p>
Other suggestions very welcome :slight_smile:
</p>
</div>
</div>


<div id="outline-container-orga72081b" class="outline-3">
<h3 id="orga72081b">Ivan Gotovchits replied</h3>
<div class="outline-text-3" id="text-orga72081b">
<blockquote>
<p>
What is the recommended way to structure modules that add extensions onto other modules that come from external packages (over which you have no control)?
</p>
</blockquote>

<ol class="org-ol">
<li>fork the project</li>
<li>extend the module</li>
<li>(optionally, but necessary) submit the patch upstream (aka PR)</li>
</ol>

<p>
Not really the answer you were looking for? Then read below. Modules in OCaml are not extensible, they are closed structures, like final classes in Java, that are not extensible <span class="underline">by design</span>. OCaml modules are not namespaces. OCaml doesn't have namespaces¹ and modules are not substitution for the namespaces. Trying to use modules as namespaces will leave both parties unhappy, you and OCaml.
</p>

<p>
Yes, it is harsh, and namespaces is the feature I miss the most when I'm developing large programs in OCaml². However, let's look deeper into the program model of OCaml to understand why this is happening and is there a right way to code in OCaml and be happy.
</p>

<p>
There are two kinds of modules in OCaml, structures and functors.  Your question is more about the former. OCaml is a language of mathematics, where structures denote <span class="underline">algebras</span>, i.e., tuples of functions attached to a set. In mathematics there is only one algebra of integers.  You can't have Janestreet's arithmetics, Matt's arithmetics, or Ivan's arithmetics. If you do, then those are different algebras with different laws, and therefore they have different structures. In other words, OCaml wasn't really designed that way, it is the essence of mathematics, our vision of mathematics that we, the humanity, have developed so far. OCaml just inherited this approach, no more no less. And this is where mathematics clashes with its offspring - programming. Yes, as software developers we need namespaces, as we need to reuse software components developed by others, we want to build systems from packages, like engineers are building complex structures from existing building blocks. Not something that mathematics is really offering us, instead it gives us the <a href="https://en.wikipedia.org/wiki/Category_theory">theory of categories</a> and <a href="https://homotopytypetheory.org/book/">homotopy type theory</a>, that are quite orthogonal to the design patterns of software engineering.
The main difference of programming as a branch of mathematics is that it has a much lower entrance barrier (you do not need to learn category theory to program) and is much more rapidly developing³. Like it or not, but programming is still mathematics and therefore we have to play by the rules of mathematics.
</p>

<p>
With all that said, you can still develop software and apply all modern software design patterns in OCaml. Just keep in mind, that a module is not a namespace, not a package, not a component. It is a mathematical structure which is fixed. It is a tuple of values. So keep those values as they are and build new values from existing, rather than trying to destructively substitute them. But before we start to explore the design space, I need to bring here two asides, so that we can develop some context for reasoning.
</p>
</div>

<div id="outline-container-org1c2b0cc" class="outline-4">
<h4 id="org1c2b0cc">Aside: The OCaml program model</h4>
<div class="outline-text-4" id="text-org1c2b0cc">
<p>
It would be interesting to look inside of OCaml to understand how modules and functions are actually implemented, what semantics the include statement has and so on. In OCaml the values are not referenced by names, unlike Common Lisp, which is the language that indeed offers proper namespacing. In fact, in OCaml values are not referenced at all, there is no such kind of indirection. Values are passed directly to each other. This is a true call-by-value, do-by-value, apply-by-value language. When we see an expression <code>f x y</code>, it is a <span class="underline">value</span> <code>f</code> which is applied to the values <code>x</code> and <code>y</code>. Not a function named <code>f</code>. When we say <code>List.length</code> it is not treated as <code>["List"; "length"]</code>, it is always and directly resolved to a concrete value of the <code>camlStdlib__list_length</code> function, which is a piece of code⁴. A module, e.g., <code>List</code> is a record (tuple) of pointers. When you do <code>include List</code> you create a new tuple and copy (as with memcpy) the contents of <code>List</code> into the new tuple. When you create an implementation of a compilation unit, in other words, when you compile an <code>ml</code> file, you are actually creating a tuple of values or a structure. The interesting and a very important part here, is that a compilation unit is implicitly parametrized by all modules that occur free in your compilation unit. In other words, when you create a file <code>example.ml</code> with the following contents,
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> <span style="color: #a0522d;">list_length</span> = <span style="color: #228b22;">List.</span>length
</pre>
</div>

<p>
and compile it to code, then the code itself will not contain the <code>List.length</code> value. Essentially, <code>example.cmo</code> will be like a functor, which is parametrized by a list implementation. It is only during the linking phase, when an actual implementation of the <code>List</code> module will be applied, and all references to the <code>List.length</code> will be finally resolved to values. On one side, this is just a side-effect of the separate compilation system, on the other side it gives us an opportunity to treat compilation units as software components and build our software systems on this granularity. But we are not yet at this phase, despite several recent improvements in the OCaml infrastructure, which include bug fixing in the dynamic linker, module aliasing, new dependency analysis, and, last but not least, Dune, compilation units are still not the building blocks. From the program model standing point, we still are operating with values, not with names.
</p>
</div>
</div>


<div id="outline-container-org26d75b1" class="outline-4">
<h4 id="org26d75b1">Aside: Common Lisp, modules, and namespaces</h4>
<div class="outline-text-4" id="text-org26d75b1">
<p>
It is also interesting to look into other languages, which provide proper namespaces. Let's pick the Common Lisp as a working example. In Common Lisp we have a notion of symbol, which denotes an object identity. When you call a function <code>(f x y)</code> you are not applying a value <code>f</code> to <code>x</code> and <code>y</code>, like you do in OCaml, but instead you are passing a symbol <code>f</code> and the runtime extracts a pointer to a function from a specific slot of the symbol object. This is basically the same, as we would be passing references to functions, e.g., if <code>let list_length = ref List.length</code>, and then calling it like <code>!list_length [1;2;3]</code>. This  is, in fact, the operational model of languages with namespaces, you never call a function, you call a name of a function and the name is a variable, which changes dynamically (the level of dynamism differs from language to language). There are, of course, cons and pros of this design. The main disadvantage is that it is hard to reason about the program behavior. Because now every program is not a mathematical object built from other mathematical objects, but rather an expression in the theory of names, that have multiple interpretations in the space of the cartesian product of the sets that denote each symbol. In other words, each program term has many interpretations, like what is <code>!list_length [1;2;3]</code>? You may never be sure.
</p>

<p>
There is also another lesson, that we can learn from languages with namespaces. The lesson is, you still need modules. For example, in Common Lisp, despite the presence of proper namespaces, programmers are still use names like <code>list-length</code>, but not <code>list:length</code>. Why so? Because <code>list-length</code> denotes an operation in the theory of <code>lists</code> with well defined meaning. It is not just a name, but an abstraction, therefore there could be <code>edu.cmu.ece:list-length</code> or <code>com.janestreet.core:list-length</code>. Therefore, we have an implicit (designed by convention) module <code>list</code> with some well-known names, which define a structure of the <code>list</code> algebra. So the takeaway is &#x2013; modules and packages are orthogonal.
</p>
</div>
</div>

<div id="outline-container-org9103c0c" class="outline-4">
<h4 id="org9103c0c">Design for extension: choices</h4>
<div class="outline-text-4" id="text-org9103c0c">
<p>
OCaml is a very rich language, that means it has a huge search space for the design choices. It also means, that most likely it is possible to implement any design pattern that you can find in the wild. This design space is not really fully explored (especially since the last years OCaml is rapidly developing) and not all decisions are well accepted by the community. For example, we have classes, which if being adopted by the community, could solve the module extension problem. Imagine, if instead of having the <code>List</code> module we had instead the <code>list</code> class. Now, the extension would be simply an inheritance, and names will be all properly indirected, as now when you will do <code>list#length</code> you will actually reference a symbol which will have multiple interpretations. However, the community didn't really adopt this design. Well, mostly because it ended up in a nightmare :)  And it is not really about classes. Classes in OCaml is just an attempt to tame the names problem. You can go rogue and actually use records of functions instead. And even  make them references, e.g.,
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">let</span> 'a <span style="color: #a0522d;">lists</span> = {
   <span style="color: #a020f0;">mutable</span> length : 'a list -&gt; int;
   <span style="color: #a020f0;">mutable</span> nth : 'a list -&gt; int -&gt; 'a;
}
</pre>
</div>

<p>
And use it like <code>list.length [1;2;3]</code>. The extension is a little bit hard, as records do not have row-types or an include statement (unlike objects and structures), but enables overriding. This approach is also not extremely popular, but was adopted at least in ppx rewriters.
</p>

<p>
So, this is all to say, that in OCaml it is possible to adopt any poor choice that was made in the software developing community. Fortunately, they are not very popular (that of course doesn't prove that they are wrong). So, what is the OCaml way of designing reusable components? Ideally, components that follow the <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle">Open-Closed principle</a>. The solution is to design for extension.
</p>

<p>
Not everything should be designed this way. This would one of those poor choices. Some entities are inherently and fundamentally not extensible. They are algebras. In the ideal world full of mathematicians and infinite time, we should define algebras as their least fixed points (aka initial algebras). For example, the initial algebra of list (i.e., the minimum set of definitions) is its type definition, so the module <code>List</code> shall have only one entry (which denotes two constructors).
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">module</span> <span style="color: #228b22;">List</span> = <span style="color: #000000; font-weight: bold;">struct</span>
   <span style="color: #000000; font-weight: bold;">type</span> <span style="color: #228b22;">'a t</span> = <span style="color: #000000; background-color: #ffffff;">[]</span> | <span style="color: #000000; background-color: #ffffff;">::</span> <span style="color: #a020f0;">of</span> 'a * 'a t
<span style="color: #000000; font-weight: bold;">end</span>
</pre>
</div>

<p>
Everything else should be put aside of the <code>List</code> module, because it is secondary, e.g., we can have a component called <code>stdlib_list_basic_operations.ml</code> which you could link into your final solution and use it, which will basically have the following interface
</p>

<div class="org-src-container">
<pre class="src src-ocaml"><span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">list_length</span> : 'a <span style="color: #228b22;">List.</span>t -&gt; int
<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">list_nth</span> : 'a <span style="color: #228b22;">List.</span>t -&gt; int -&gt; 'a
<span style="color: #000000; font-weight: bold;">val</span> <span style="color: #0000ff;">list_hd</span> : 'a <span style="color: #228b22;">List.</span>t -&gt; 'a
</pre>
</div>

<p>
With this approach, it would be easy to compose different components, as there wouldn't be any more competition for the <code>List</code> module, but instead the list interface will be composed by convention. Anyone could provide a <code>list_something</code> function and it is your choice as the system developer to select the right components and glue them tightly and correctly. This is, basically, the approach that is used in Common Lisp, C++, Java, and other languages.
</p>

<p>
Unfortunately, this is not the convention in OCaml. While the initial design of the OCaml exhibits some notions of this approach (cf., <code>string_of_int</code>, <code>int_of_string</code>, and the <code>Pervasives</code> module itself), at some point of time, this venue was abandoned, and OCaml developers sticked to the "blessed module" approach.  In this approach, operations are blessed by being included in the main module and all other operations are sort of the second sort citizens. As a result, we have modules with exploded interfaces, which are hard to maintain, use, and it takes so much time to compile programs that use Janestreet's libraries.
</p>
</div>
</div>

<div id="outline-container-org8fc710b" class="outline-4">
<h4 id="org8fc710b">Summary</h4>
<div class="outline-text-4" id="text-org8fc710b">
<p>
Design for extensibility, when the extensibility is expected. Use small modules, which define abstractions. Protect those abstractions. If a function doesn't require the access to the internal representation, doesn't rely on the internal invariants of the representation, and could be efficiently implemented using the abstract interface only, the do not put it into the module. Good example, <code>list_length</code> -  not a part of the module. But <code>Map.length</code> is, since it needs to access the internal representation of the binary tree. Nor it could be efficiently implemented using <code>Map.fold</code>. Implement all other functions in separate modules, probably structured by their purposes and domains. Use the <code>open!</code> statements to introduce those names into your namespace.
</p>

<p>
When you design a software component that should be extensible, parametrize it with abstractions. Use functors, function parameters, whatever &#x2013; OCaml gives you a lot of options here. You can even use references to functions, which work especially good with dynamic linking.
</p>

<p>
When you find someone else's code which is broken, either because of a missing function in the interface or a wrong implementation do not hesitate to fork, patch, and submit. In fact, Dune facilitates this approach, so that you can create your own workspaces with core, base, and whatever libraries, edit them to your taste and get a working solution. If you want it to be reusable &#x2013; then push the changes back. And we are back where we started.  Yes, you can do the <code>include</code> trick and reexport your own <code>List</code> module, but this is essentially the same as cloning, patching&#x2026; but not submitting back. Because, at the end of the day we will now have <code>Base.List</code>, <code>Core.List</code>, <code>Matt.List</code>, how does it differ from having multiple forks on github or, even worse, vendoring those modules? Essentially, it is the same. So,
</p>

<ol class="org-ol">
<li>fork the project</li>
<li>extend the module</li>
<li>push it back</li>
</ol>

<p>
but before doing this, ask yourself, is the operation that I'm trying to add is really a member of this module?
</p>

<p>
¹: And will never have, because OCaml  program model operates on values, not on names, as Common Lisp for example.
</p>

<p>
²: However, when I develop large programs in other languages I miss OCaml modules much more, than I miss namespaces in OCaml :slight_smile:
</p>

<p>
³: Programming is like mathematics without elitist approach, which is really good.
</p>

<p>
⁴: Don't worry it is still represented as a pointer, but essentially it is the code.
</p>
</div>
</div>
</div>


<div id="outline-container-org0977dd4" class="outline-3">
<h3 id="org0977dd4">Matt Windsor then said</h3>
<div class="outline-text-3" id="text-org0977dd4">
<p>
This is a really comprehensive and thoughtful answer, and somewhat confirms my suspicions about what I'm doing being a fairly bad idea—thanks!
</p>

<p>
&gt; ask yourself, is the operation that I’m trying to add is really a member of this module?
</p>

<p>
Generally: no.  What I'm doing is trying to insert operations over <code>List</code>​s, etc., that don't directly depend on the intrinsics of how the lists are defined, but instead back-form implementations of patterns that are specific to the library I'm designing.  Effectively, I'm trying to do what you'd do with extension methods in C#, or by defining instances of a new typeclass I've made over <code>Base.List</code>.  (Indeed, I'm coming to OCaml through C#-via-F# and Haskell, so these are the mental models I'm already hardwired to try implement.)
</p>

<p>
So, if I consider what I'm doing as 'here is a <code>List</code> module and I'm just yanking all of <code>Base.List</code> into it while exposing the fact that I've done so', then… of course it makes no sense!
</p>

<p>
It also makes no sense for me to try to send what I'm doing upstream, because, while I might think that what I'm doing to <code>List</code> is generally useful, it doesn't make any sense outside the environment that my library is doing, nor is it a key part of <code>List</code>'s initial algebra (it might well define algebraic properties on <code>List</code>, but they're derived ones), and putting it in <code>Base</code> or <code>Core_kernel</code> would be bloat.
</p>

<p>
I got confused by the fact that <code>Core_kernel</code> really does just sit on top of <code>Base</code> in the way that I was trying to do&#x2014;but this is a special case that doesn't generalise to what I want to do at all.
</p>
</div>
</div>
</div>




<div id="outline-container-orge4223d4" class="outline-2">
<h2 id="3">PSA: dns 2.0 &#x2013; a new udns era dawns</h2>
<div class="outline-text-2" id="text-3">
<p>
Archive: <a href="https://discuss.ocaml.org/t/psa-dns-2-0-a-new-udns-era-dawns/3781/1">https://discuss.ocaml.org/t/psa-dns-2-0-a-new-udns-era-dawns/3781/1</a>
</p>
</div>

<div id="outline-container-orgee9c9bd" class="outline-3">
<h3 id="orgee9c9bd">Anil Madhavapeddy announced</h3>
<div class="outline-text-3" id="text-orgee9c9bd">
<p>
The <a href="https://github.com/mirage/ocaml-dns">DNS protocol implementation</a> in MirageOS has been around for a very, very long time.  The codebase began way back in 2003 and got used in research projects such as <a href="http://anil.recoil.org/papers/2007-eurosys-melange.pdf">Melange</a> (the precursor to MirageOS) and <a href="https://tjd.phlegethon.org/words/thesis.pdf">the Main Name System</a>.
</p>

<p>
Over the years, the ocaml-dns codebase has been refactored many times as we developed new libraries: early versions were moved from a declarative parsing language (<a href="https://github.com/avsm/mpl">lost</a> in the sands of time) over <a href="https://github.com/mirage/ocaml-dns/pull/3">to bitstring</a> and then to the newly developed <a href="https://github.com/mirage/ocaml-cstruct">cstruct</a> and so on.  Meanwhile, our overall coding standards and library infrastructure in MirageOS also improved, and the DNS codebase didn't always keep up.
</p>

<p>
The DNS interfaces tended to leak exceptions from awkward places, whereas other Mirage libraries have been adopting an <a href="https://github.com/mirage/mirage/pull/743">explicit approach to error handling</a> to ensure exceptions are indeed exceptional events.  The DNS protocol itself has continued to grow many more extensions, and now systems such as <a href="https://letsencrypt.org">LetsEncrypt</a> that can generate TLS certificates via DNS really motivate supporting these.
</p>

<p>
So it is with enormous pleasure that I recently merged <a href="https://github.com/mirage/ocaml-dns/pull/159">mirage/ocaml-dns#159</a> into the trunk branch of the DNS repository.  This represents a rewrite of the implementation of DNS from the ground up using the same rigorous coding standards first adopted in <a href="https://github.com/mirage/ocaml-tls">ocaml-tls</a>, and spearheaded for over two years by @hannes and @cfcs in their <a href="https://github.com/roburio/udns">udns library</a>.  As udns has matured, we recently took the decision for it to merge with the venerable ocaml-dns repository and supplant the old implementation.  You can view the <a href="https://mirage.github.io/ocaml-dns/">odoc of the master branch</a> online.
</p>

<p>
This means that the dns.2.0.0 package will essentially be udns (which has deliberately not been released to date).  The first thing I would like to do is to thank @hannes and @cfcs for their enormous persistence and attention to detail in constructing this new version, and then secondly to issue a call for help and contributions from anyone in the OCaml community who is interested in assisting with missing features that have regressed from the 1.x branch.
</p>

<p>
The core library is in great shape, so I have created some issues for known missing elements that we can tackle before cutting a dns.2.0.0 release:
</p>

<ul class="org-ul">
<li><a href="https://github.com/mirage/ocaml-dns/issues/161">create an Async-based resolver</a></li>
<li><a href="https://github.com/mirage/ocaml-dns/issues/160">multicast DNS</a></li>
<li><a href="https://github.com/mirage/ocaml-dns/issues/106">localhost tests using mirage-vnetif virtual stacks</a></li>
<li><a href="https://github.com/mirage/ocaml-dns/issues/44">server-side TCP requests</a></li>
</ul>

<p>
If you are a current user of the dns.1.x branch, we would also really like to hear from you about whether the <code>master</code> branch of <a href="https://github.com/mirage/ocaml-dns">ocaml-dns</a> is suitable for your use.  Please feel free to <a href="https://github.com/mirage/ocaml-dns/issues">create new issues</a> about regressions from 1.x, or to make suggestions.  If you're new to DNS and curious to learn more, then do also try to do your own deployment of a DNS server and let us know how it goes!
</p>

<p>
mirage.io will shortly be running this DNS server as well, of course, and @hannes can no doubt chime in about his own usecases in production with this new codebase over the past few years.
</p>

<p>
Enjoy!
</p>
</div>
</div>


<div id="outline-container-orgc375558" class="outline-3">
<h3 id="orgc375558">Hannes Mehnert then said</h3>
<div class="outline-text-3" id="text-orgc375558">
<p>
I don't quite understand what you mean with TCP server&#x2026; if you take a look at ns0.robur.io (or ns1.robur.io) or ns1/ns2/ns3.mehnert.org or ns.nqsb.io / sn.nqsb.io (they're all running udns), they are already listening on TCP, and if your request (via udp) is too large to fit into 400 bytes, you get a truncated answer (an example would be <code>dig tlsa _letsencrypt._tcp.hannes.nqsb.io @ns.nqsb.io</code>).
</p>

<p>
for the motivation behind udns: initially i wanted to write an iterative resolver, but then the "how to configure it" question was raised, and i discovered <a href="https://tools.ietf.org/html/rfc2136">NSUPDATE</a>, an in-protocol dynamic update mechanism (with <a href="https://tools.ietf.org/html/rfc2845">authentication</a>), and started to implemented these, together with a server implementation. Afterwards I intended to use let's encrypt via DNS (since I hate to have to run web servers for let's encrypt) &#x2013; thanks to Michele, the <a href="https://github.com/mmaker/ocaml-letsencrypt">ocaml-letsencrypt</a> got me started with the DNS challenge).
</p>

<p>
nowadays, I store TLS certificates (and signing requests) as TLSA in DNS, have the zone in a git repository that is pushed and pulled by the primary implementation, which <a href="https://tools.ietf.org/html/rfc1996">NOTIFY</a> secondaries (even the let's encrypt service is a (hidden) secondary), and transfers zones <a href="https://tools.ietf.org/html/rfc1995">incrementally</a>.
</p>

<p>
if you're interested in server-side unikernels, take a look at <a href="https://github.com/roburio/unikernels">https://github.com/roburio/unikernels</a> &#x2013; they contain primary, secondary, primary-git, let's encrypt, &#x2026;
</p>

<p>
what is more to do? there are still some TODO in the code which should be fixed, the test coverage (esp. in server) is not yet optimal, and various DNS extensions (DNSSec, DNS-over-TLS, irmin-storage-in-dns, tcp-over-dns, &#x2026;) are just not there yet&#x2026; but in the end, I use and rewrite this stack since some years (first commit was from end of april 2017) &#x2013; also using the resolver on my laptop :)
</p>
</div>
</div>
</div>




<div id="outline-container-org159bf34" class="outline-2">
<h2 id="4">Next OUPS meetup May 21st 2019</h2>
<div class="outline-text-2" id="text-4">
<p>
Archive: <a href="https://sympa.inria.fr/sympa/arc/caml-list/2019-05/msg00016.html">https://sympa.inria.fr/sympa/arc/caml-list/2019-05/msg00016.html</a>
</p>
</div>

<div id="outline-container-orgdaba756" class="outline-3">
<h3 id="orgdaba756">Bruno Bernardo announced</h3>
<div class="outline-text-3" id="text-orgdaba756">
<p>
The next OUPS meetup will take place on Tuesday, May 21, 7pm at IRILL on the Jussieu campus. As usual, we will have a few talks, followed by pizzas and drinks.
</p>

<p>
The talks will be the following:
</p>

<ul class="org-ul">
<li>Nik Graf, TBD (something related to ReasonML), <a href="https://www.nikgraf.com/">https://www.nikgraf.com/</a></li>

<li>Armaël Guéneau, Incremental Cycles, A certified incremental cycle detection algorithm used in Dune, <a href="https://gitlab.inria.fr/agueneau/incremental-cycles">https://gitlab.inria.fr/agueneau/incremental-cycles</a></li>
</ul>


<p>
Please do note that we are always in demand of talk <b>proposals</b> for future meetups.
</p>

<p>
To register, or for more information, go here: <a href="https://www.meetup.com/ocaml-paris/events/261323263">https://www.meetup.com/ocaml-paris/events/261323263</a>
</p>

<p>
<b>Registration is required! Access is not guaranteed after 7pm if you're not registered.</b> (It also helps us to order the right amount of food.)
</p>

<p>
Access map: <br />
IRILL - Université Pierre et Marie Curie (Paris VI) <br />
Barre 15-16 1er étage <br />
4 Place Jussieu <br />
75005 Paris <br />
<a href="https://www.irill.org/pages/access.html">https://www.irill.org/pages/access.html</a>
</p>
</div>
</div>
</div>




<div id="outline-container-org9d53fb1" class="outline-2">
<h2 id="5">Other OCaml News</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-orgda0e47f" class="outline-3">
<h3 id="orgda0e47f">From the ocamlcore planet blog</h3>
<div class="outline-text-3" id="text-orgda0e47f">
<p>
Here are links from many OCaml blogs aggregated at <a href="http://ocaml.org/community/planet/">OCaml Planet</a>.
</p>

<ul class="org-ul">
<li><a href="https://blog.janestreet.com/thoughts-from-aaai-19/">Thoughts from AAAI 2019</a></li>
<li><a href="https://tarides.com/blog/2019-05-13-on-the-road-to-irmin-v2.html">On the road to Irmin v2</a></li>
<li><a href="https://tarides.com/blog/2019-05-09-an-introduction-to-ocaml-ppx-ecosystem.html">An introduction to OCaml PPX ecosystem</a></li>
<li><a href="http://math.andrej.com/2019/05/08/a-course-on-homotopy-type-theory/">A course on homotopy (type) theory</a></li>
</ul>
</div>
</div>
</div>




<div id="outline-container-org48d6f79" class="outline-2">
<h2 id="org48d6f79">Old CWN</h2>
<div class="outline-text-2" id="text-org48d6f79">
<p>
If you happen to miss a CWN, you can <a href="mailto:alan.schmitt@polytechnique.org">send me a message</a> and I'll mail it to you, or go take a look at <a href="http://alan.petitepomme.net/cwn/">the archive</a> or the <a href="http://alan.petitepomme.net/cwn/cwn.rss">RSS feed of the archives</a>.
</p>

<p>
If you also wish to receive it every week by mail, you may subscribe <a href="http://lists.idyll.org/listinfo/caml-news-weekly/">online</a>.
</p>

<div class="authorname">
<p>
<a href="http://alan.petitepomme.net/">Alan Schmitt</a>
</p>

</div>
</div>
</div>
</div>
</body>
</html>
