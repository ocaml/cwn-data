<?xml version="1.0" encoding="UTF-8"?>
<cwn>
  <cwn_head>
    <cwn_date>2018.09.25</cwn_date>
    <cwn_prev>2018.09.18</cwn_prev>
    <cwn_next>2018.10.02</cwn_next>
    <cwn_date_text>September 18 to 25, 2018</cwn_date_text>
  </cwn_head>
  <cwn_body>
    <cwn_entry>
      <cwn_title>Release of Teash 0.1.0</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ann-release-of-teash-0-1-0/2577/1</cwn_url>
      <cwn_who>Johan Stenqvist announced</cwn_who>
      <cwn_what>
Hi, I'm happy to announce that the initial release of Teash is now available from opam.

Teash is an implementation of "The Elm Architecture", for the shell. It may be used to build interactive terminal applications that adheres to the ~Model -&gt; Update -&gt; View~ paradigm.

Please don't hesitate to drop by https://github.com/neochrome/teash and leave feedback/issues if you find it useful.
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>OCaml wrapper on top of a Random Forests implementation</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ocaml-wrapper-on-top-of-a-random-forests-implementation/2579/1</cwn_url>
      <cwn_who>UnixJunkie announced</cwn_who>
      <cwn_what>
I made yet another wrapper.
It is here:
https://github.com/UnixJunkie/oranger

It can be used for classification and regression.
There is a test here:
https://github.com/UnixJunkie/oranger/blob/master/src/test.ml

This package relies on the C++ ranger implementation:
https://github.com/imbs-hl/ranger

this package does not depend on R.

It is quite hackish and doesn't support sparse data also (I need to know how ranger
supports them first).
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>opam 2.0.0 final release and repository upgrade</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ann-opam-2-0-0-final-release-and-repository-upgrade/2585/1</cwn_url>
      <cwn_who>R. Boujbel announced</cwn_who>
      <cwn_what>
We are happy to announce the *opam 2.0.0 final release*.

A few weeks ago, we released a last release candidate to be later promoted to 2.0.0, synchronised with the opam package repository upgrade to 2.0.0.

More information in this [blog post](https://opam.ocaml.org/blog/opam-2-0-0/).

We want to thank opam repository maintainers and OS maintainers for their help.
      </cwn_what>
      <cwn_who>Perry E. Metzger said</cwn_who>
      <cwn_what>
I've upgraded the opam package in MacPorts to 2.0.0, so MacPorts users can upgrade opam that way quite easily.
      </cwn_what>
      <cwn_who>Marek Kubica also said</cwn_who>
      <cwn_what>
Same with homebrew, the pull request was just merged today.
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>A client library for the Zeit API and Δ now.sh</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ann-a-client-library-for-the-zeit-api-and-now-sh/2589/1</cwn_url>
      <cwn_who>Etienne Millon announced</cwn_who>
      <cwn_what>
https://now.sh is a service to do easy serverless deployments. It's a way to
deploy a web site or application without managing a server directly. Deployments
are handled through the [Zeit API](https://zeit.co/api). The official client is
a Node application, which might be a bit heavy for some use cases.

I am happy to announce the release of an OCaml client for this API. It can be
used to trigger deployments from an OCaml application. It is available [on
github](https://github.com/emillon/ocaml-zeit) &amp; [on
opam](http://opam.ocaml.org/packages/zeit/) as ~opam install zeit~. [An example
program](https://github.com/emillon/ocaml-zeit/blob/cdcdd0b155d406d1b8c8947e3c620527c3c9ecf7/bin/maintenant.ml)
is included to demonstrate what the API looks like.

This exposes very few endpoints at the moment, but we plan to use this in the near future to make a better story around deploying OCaml applications.
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>Next OUPS meetup October 1st 2018</cwn_title>
      <cwn_url>https://sympa.inria.fr/sympa/arc/caml-list/2018-09/msg00033.html</cwn_url>
      <cwn_who>Bruno Bernardo announced</cwn_who>
      <cwn_what>
The OUPS meetup is back. The next one will take place on Monday,
October 1, 7pm at IRILL on the Jussieu campus.
As usual, we will have a few talks, followed by pizzas and drinks.

The talks will be the following:
- Berke Durak: OCaml in space: embedded software and numerical analysis
- Armaël Guéneau: Complexity proofs for OCaml programs with CFML
- Paul Laforgue: Copattern matching in OCaml

Please do note that we are always in demand of talk /proposals/ for future
meetups.

To register, or for more information, go here:
https://www.meetup.com/ocaml-paris/events/254849756/

/Registration is required! Access is not guaranteed after 7pm if
you're not registered./ (It also helps us to order the right amount of
food.)

Access map: \\
IRILL - Université Pierre et Marie Curie (Paris VI) \\
Barre 15-16 1er étage \\
4 Place Jussieu \\
75005 Paris \\
https://www.irill.org/pages/access.html
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>Release Candidate 4.07.1+rc1</cwn_title>
      <cwn_url>https://sympa.inria.fr/sympa/arc/caml-list/2018-09/msg00040.html</cwn_url>
      <cwn_who>Damien Doligez announced</cwn_who>
      <cwn_what>
Dear OCaml users,

The release of OCaml version 4.07.1 is imminent.  We have
created a release candidate for your testing pleasure.  Please
try it in opam and test your favourite software with it.  Then
let me know whether it works for you.

We want to know about any show-stopping bugs, especially in the
compilation and installation phases.

This release candidate will soon be available as a bunch of OPAM
switches. It is also available as source code at this address:
  http://caml.inria.fr/pub/distrib/ocaml-4.07/

Happy hacking,

-- Damien Doligez for the OCaml team.
      </cwn_what>
      <cwn_who>Damien Doligez then added</cwn_who>
      <cwn_what>
Sorry, I forgot to include the Changes list. See the end of this mail.

*** Bug fixes:

- MPR#7815, GPR#1896: major GC crash with first-fit policy
  (Stephen Dolan and Damien Doligez, report by Joris Giovannangeli)

- * MPR#7818, GPR#2051: Remove local aliases in functor argument types,
  to prevent the aliasing of their target.
  (Jacques Garrigue, report by mandrykin, review by Leo White)

- MPR#7820, GPR#1897: Fix Array.of_seq. This function used to apply a circular
  permutation of one cell to the right on the sequence.
  (Thierry Martinez, review by Nicolás Ojeda Bär)

- MPR#7821, GPR#1908: make sure that the compilation of extension
  constructors doesn't cause the compiler to load more cmi files
  (Jérémie Dimino)

- MPR#7824, GPR#1914: subtype_row: filter out absent fields when row is closed
  (Leo White and Thomas Refis, report by talex, review by Jacques Garrigue)

- GPR#1915: rec_check.ml is too permissive for certain class declarations.
  (Alban Reynaud with Gabriel Scherer, review by Jeremy Yallop)

- MPR#7833, MPR#7835, MPR#7822, GPR#1997: Track newtype level again
  (Leo White, reports by Jerome Simeon, Thomas Refis and Florian
  Angeletti, review by Jacques Garrigue)

- MPR#7838: -principal causes assertion failure in type checker
  (Jacques Garrigue, report by Markus Mottl, review by Thomas Refis)
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>Caqti 1.0.0</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ann-caqti-1-0-0/2609/1</cwn_url>
      <cwn_who>Petter A. Urkedal announced</cwn_who>
      <cwn_what>
Caqti is an abstraction layer over relational database client libraries,
currently supporting MariaDB, PostgreSQL and Sqlite3 providing monadic
concurrency, connection pools, and unified parameter handling.

I am please to announce the first formally stable release, with the following highlights from the change log:

- Applied an essential fix of ptime to string conversion for PostgreSQL by @monstasat, with apologies for the delayed release to anyone who might have encountered the issue.
- Support microsecond precision for MariaDB.  This completes the support for full time precision in all drivers.

and some adjustments of the API:

- Added ~Caqti_type.Std : Caqti_type_sig.Std~, containing type descriptors needed for building requests, for easy inclusion in custom modules.
- Removed ~Caqti_type.Field.ex~ and renamed ~Caqti_type.ex~ to  ~Caqti_type.any~ and related functions.
- Removed other deprecated definitions.
- Moved ~Caqti_system_sig~ into ~Caqti_driver~ and split up the signature to  make room for future drivers on alternative platforms.
      </cwn_what>
      <cwn_who>Petter A. Urkedal later added</cwn_who>
      <cwn_what>
- [Project page](https://github.com/paurkedal/ocaml-caqti)
- [API reference](http://paurkedal.github.io/ocaml-caqti/index.html)

There is also a nice [introductory tutorial](https://medium.com/@bobbypriambodo/interfacing-ocaml-and-postgresql-with-caqti-a92515bdaa11) on Medium.
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>Mirage 3.2.0</cwn_title>
      <cwn_url>https://discuss.ocaml.org/t/ann-mirage-3-2-0/2613/1</cwn_url>
      <cwn_who>Hannes Mehnert announced</cwn_who>
      <cwn_what>
it is my pleasure to announce that mirage 3.2.0 has been released to opam-repository(~*~).  This release contains breaking changes with earlier releases:

It requires solo5 0.4.0, which renames "ukvm" to "hvt" (thanks to Martin Lucina)
It requires tcpip 3.5.0, which removes complexity from stack initialisation (thanks to Hannes Mehnert)

Mirage now comes with the hvt (Hardware Virtualization Tender) target (earlier known as ukvm), which works on Linux/KVM, OpenBSD/VMM (since 6.4), and FreeBSD/VMM|BHyve.

*** Upgrading from Mirage 3.1.x or earlier

Due to conflicting packages, opam will not upgrade mirage to version 3.2.0 or
newer if a version of mirage-solo5 older than 0.4.0 is installed in the switch.
To perform the upgrade you must run ~opam upgrade mirage~ explicitly.

**** Changes required to rebuild and run ukvm unikernels

As of Solo5 0.4.0, the ukvm target has been renamed to hvt. If you are working out of an existing, dirty, source tree, you should initially run:

#+begin_src shell
mirage configure -t hvt
mirage clean
mirage configure -t hvt
#+end_src

and then proceed as normal. If you are working with a clean source tree, then simply configuring with the new hvt target is sufficient:

~mirage configure -t hvt~

Note that the build products have changed:

The unikernel binary is now named ~&lt;unikernel&gt;.hvt~, the ~ukvm-bin~ binary is now named ~solo5-hvt~.

*** adapt to mirage-protocols, mirage-stack, tcpip changes

This is a breaking change: mirage 3.2.0 requires mirage-protocols 1.4.0,
mirage-stack 1.3.0, and tcpip 3.5.0 to work (charru-client-mirage 0.10 and
mirage-qubes-ipv4 0.6 are adapted to the changes). An older mirage won't be able
to use these new libraries correctly. Conflicts were introduced in the
opam-repository.

In more detail, direct and socket stack initialisation changed, which is
automatically generated by the mirage tool for each unikernel (as part of
~main.ml~). A record was built up, which is no longer needed.

Several unneeded type aliases were removed:
- ~netif~ from Mirage_protocols.ETHIF
- ~ethif~ and ~prefix~ from Mirage_protocols.IP
- ~ip~ from Mirage_protocols.{UDP,TCP}
- ~netif~ and ~'netif config~ from Mirage_stack.V4
- ~'netif stackv4_config~ and ~socket_stack_config~ in Mirage_stack


Regards,

hannes

~*~: which since a week switched to opam 2.0, and thus you'll only see updates if you upgraded your opam to 2.0 (you can do so by following the instructions on https://opam.ocaml.org/blog/opam-2-0-0/)
      </cwn_what>
      <cwn_who>Christian Lindig asked and Thomas Gazagnaire replied</cwn_who>
      <cwn_what>
&gt; Could you give a summary (or provide a link) what Mirage is and what it is good for?

You can see Mirage as the sum of three components:

1. A set of system APIs. We have module types for each of the main device drivers (low-level like network and storage but also higher level drivers like HTTP and TLS devices). See for instance [mirage-protocols](https://github.com/mirage/mirage-protocols) for the module types related to our TCP/IP stack.

2. A set of packages implementing these API. These could be backend-specific (like [Unix](https://github.com/mirage/mirage-net-unix), [Xen](https://github.com/mirage/mirage-net-xen), or [solo5](https://github.com/mirage/mirage-net-solo5) (to target kvm), or [ESP32](https://github.com/well-typed-lightbulbs/mirage-net-impl-esp32)) or generic (like an [HTTP server](https://github.com/mirage/ocaml-cohttp/tree/master/cohttp-mirage/src), a Git implementation, etc). The generic implementations are functors over the set of APIs defined in 1.

3. A configuration DSL ([functoria](https://github.com/mirage/functoria)) and a command-line tool ([mirage](https://github.com/mirage/mirage)) to bind them all.

You can read more about this on the [MirageOS](https://mirage.io) website, including links to papers, tutorials, etc.
      </cwn_what>
      <cwn_who>Thomas Gazagnaire then added</cwn_who>
      <cwn_what>
And here a few examples of how to use MirageOS:

- you want to have a total control on your runtime environment: you can use mirage to build a very specialised OS that you can statically link to your application. This removes the need an underlying general purpose OS and produce small deployment images (a few Mo) with low ressource consumptions (a few Mo), so you could increase the density of your deployments. The images are also secure as the attack surfaces is reduced, see for instance the [bitcoin pinata](http://ownme.ipredator.se/).

- you want to build a "system" application (e.g. a firewall, a reverse TCP/IP stack): you can pick the Mirage libraries that you need an include these in your application. See for instance [VPNKit](https://github.com/moby/vpnkit) or [Qubes firewall](http://roscidus.com/blog/blog/2016/01/01/a-unikernel-firewall-for-qubesos/).
      </cwn_what>
      <cwn_who>Perry E. Metzger also replied</cwn_who>
      <cwn_what>
&gt; Could you give a summary (or provide a link) what Mirage is and what it is good for?

Perhaps as an outsider I can give a somewhat different summary.

Mirage is a library that acts as an operating system — it allows you to
construct an OCaml program that boots directly on top of a virtual machine
hypervisor by providing your program all the system services it needs to boot on
not-quite-bare metal. It has all the services you would usually expect in an
operating system, like a TCP/IP stack and drivers and all the rest.

(The [Unikernel wikipedia page](https://en.wikipedia.org/wiki/Unikernel) gives some more explanation of the approach.)

This lets you construct very small, very specialized machine images where the
entire stack is written in OCaml. If you want to build (say) a very small, very
secure system appliance (like a small firewall + router), this is one cool way
to do it. That said, you can in theory build any sort of "boots on bare metal"
system you like with it, just as you can put any application you like on top of
Unix. The limitation is that everything runs in one address space, but that's
also the joy of it.
      </cwn_what>
      <cwn_who>Perry E. Metzger asked and Martin Lucina replied</cwn_who>
      <cwn_what>
&gt; How does Mirage handle multiple processors?

It doesn't; like most unikernels I've seen to date the design choice is to
remain single-core and use a cooperative scheduler. If you want to scale out to
multiple cores then the idea is you run multiple instances of your unikernel,
and the scheduling of unikernels to cores is handled by the hypervisor (or other
"host" system).

&gt; Can Mirage boot on actual bare metal?

It can, but the only example I know of to date is the ESP32 port ([blog](https://www.lortex.org/esp32/), [implementation](https://github.com/well-typed-lightbulbs/mirage-impl-esp32/)).

The OCaml runtime is extremely easy to re-target to anything and requires only
minimal C dependencies (see e.g.
[ocaml-freestanding](https://github.com/mirage/ocaml-freestanding)), so actual
bare metal is mainly a question of writing the low-level platform startup code,
and then the actual hardware drivers you might need (which can be in OCaml).

By the way, thank you for your summary write-up of Mirage. Sometimes it's hard to explain to people as an insider what exactly a project is good for.
      </cwn_what>
      <cwn_who>Perry E. Metzger asked and Hannes Mehnert replied</cwn_who>
      <cwn_what>
&gt; the Mirage repository have USB controller and similar drivers?

No, there isn't any USB (or other) drivers yet.

Just to clear up the wording here: there is no "mirage repository", but being a
library operating system, each MirageOS unikernel consists of hundreds of OCaml
libraries, all released to the opam-repository.
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>Other OCaml News</cwn_title>
      <cwn_who>From the ocamlcore planet blog</cwn_who>
      <cwn_what>
Here are links from many OCaml blogs aggregated at [[http://ocaml.org/community/planet/][OCaml Planet]].

- [[http://www.ocamlpro.com/2018/09/19/opam-2-0-0-release-and-repository-upgrade/][opam 2.0.0 release and repository upgrade]]
      </cwn_what>
    </cwn_entry>
  </cwn_body>
</cwn>
