<?xml version="1.0" encoding="UTF-8"?>
<cwn>
  <cwn_head>
    <cwn_date>2015.04.07</cwn_date>
    <cwn_prev>2015.03.31</cwn_prev>
    <cwn_next>2015.04.14</cwn_next>
    <cwn_date_text>March 31 to April 07, 2015</cwn_date_text>
  </cwn_head>
  <cwn_body>
    <cwn_entry>
      <cwn_title>GADTs and Menhir</cwn_title>
      <cwn_url>https://sympa.inria.fr/sympa/arc/caml-list/2015-03/msg00169.html</cwn_url>
      <cwn_who>Andre Nathan asked</cwn_who>
      <cwn_what>
I'm trying to learn a bit about GADTs, but I can't figure out how to
make them work with Menhir.

I have defined the following GADT:

(* foo.ml *)

type 'a t =
  | Int : int -&gt; int t
  | Bool : bool -&gt; bool t

With this definition I can write an "eval" function as

let eval (type t) (foo : t Foo.t) : t =
  match foo with
  | Foo.Int i -&gt; i
  | Foo.Bool b -&gt; b

Now considering the simple parser and lexer below,

(* parser.mly *)

%{ open Foo %}

%token &lt;int&gt; INTEGER
%token &lt;bool&gt; BOOL
%token EOF

%start &lt;'a Foo.t&gt; start
%%

start:
  | value; EOF { $1 }
  ;
value:
  | i = INTEGER  { Int i }
  | b = BOOL     { Bool b }
  ;

(* lexer.mll *)

{ open Parser }

let digit = ['0'-'9']
let boolean = "true" | "false"

rule token = parse
  | [' ' '\t']             { token lexbuf }
  | '\n'                   { Lexing.new_line lexbuf; token lexbuf }
  | digit+ as i            { INTEGER (int_of_string i) }
  | boolean as b           { BOOL (bool_of_string b) }
  | eof                    { EOF }

when I try to compile this I get the error below:

File "parser.mly", line 15, characters 43-52:
Error: This expression has type int Foo.t
       but an expression was expected of type bool Foo.t
       Type int is not compatible with type bool

This is the

  | b = BOOL     { Bool b }

line. I believe the error comes from not having the locally-abstract
type annotations in the code generated by Menhir.

Is there any way around this?
      </cwn_what>
      <cwn_who>Francois Pottier replied</cwn_who>
      <cwn_what>
&gt; value:
&gt;   | i = INTEGER  { Int i }
&gt;   | b = BOOL     { Bool b }

The problem lies here. What is the OCaml type of the symbol "value"? The OCaml
compiler complains that in one branch it seems to be int Foo.t, but in the
other branch it seems to be bool Foo.t. (The problem does not have anything to
do with Menhir, really.)

Usually, it is not advisable to try to perform parsing and type-checking in
one single phase. So, my advice would be to:

  1- perform parsing in the usual way,
     constructing ASTs in a normal algebraic data type "ast"
     (not a GADT);

  2- perform type-checking (or type inference).
     If you insist on using GADTs, you will probably need
     a GADT of terms (your type 'a Foo.t) and
     a GADT of type representations ('a ty)
     and the type-checking function will have type
     ast -&gt; 'a ty -&gt; 'a Foo.t option
     which means that, given an untyped term and
     a representation of an expected type, it
     either fails or succeeds and produces a typed term.

There are examples of this kind of thing online, e.g.
http://www.cs.ox.ac.uk/projects/gip/school/tc.hs
by Stephanie Weirich.
      </cwn_what>
      <cwn_who>Andre Nathan then asked and later added</cwn_who>
      <cwn_what>
&gt; Can you give me an example of what this "GADT of type representations"
&gt; would look like? I couldn't understand the Haskell example...

I found a reference to an email from Jeremy Yallop to the list from 2013
[1], and managed to get it working with the following solution:

(* foo.ml *)
open Printf

type 'a t =
  | Int : int -&gt; int t
  | Bool : bool -&gt; bool t

type ast =
  [ `Int of int
  | `Bool of bool
  ]

type any =
  | Any : 'a t -&gt; any

let typed = function
  | `Int i -&gt; Any (Int i)
  | `Bool b -&gt; Any (Bool b)

let print : type a. a t -&gt; unit = function
  | Int i -&gt; printf "%d\n" i
  | Bool b -&gt; printf "%b\n" b

The parser now returns a `Foo.ast`:

value:
  | i = INTEGER { `Int i }
  | b = BOOL    { `Bool b }
  ;

and with that I can print the parsed value with

  let ast = Parser.start Lexer.token lexbuf in
  let Foo.Any t = Foo.typed ast in
  Foo.print t

I'm happy that it works, but the `any` type is a bit of a mistery to me.
In Jeremy's email it's explained as

"An existential to hide the type index of a well-typed AST, making it
possible to write functions that return constructed ASTs whose type is
not statically known."

Does anyone have a reference to literature that explains this technique
(I'm guessing that would be Pierce's book)? The OCaml manual briefly
shows an example with a `dyn` type, but not much is said about it.
      </cwn_what>
      <cwn_who>Jeremy Yallop replied</cwn_who>
      <cwn_what>
There's a more detailed explanation of the technique in the lecture
notes on the following page:

   http://www.cl.cam.ac.uk/teaching/1415/L28/materials.html

The section you want is

    8.4.2 Pattern: building GADT values

on p83 of the notes from 9 February, but it might also be helpful to
look through some of the earlier notes for background.
      </cwn_what>
      <cwn_who>Gerd Stolpmann also replied</cwn_who>
      <cwn_what>
A couple of weeks ago I ran into the same problem. It is just a matter
of not being accustomed to how GADTs work, and not having the right
design patterns in your mind.

OCaml users are used to expose any polymorphism and that it is not
directly possible to hide it. So, normally if there is a variable 'a on
the right side of the type definition, it must also appear on the left
side (e.g. type 'a foo = Case1 of 'a | Case2 of ...). This is not
required for GADTs, because the variable is bound by the case it applies
to (i.e. for the Int case you have 'a=int and for the Bool case you have
'a=bool). So it is implicitly known. Because of this, many people prefer
to write

type _ t =                  (* look here, no 'a anymore *)
  | Int : int -&gt; int t
  | Bool : bool -&gt; bool t

and 

type any =
  | Any : _ t -&gt; any

The type parameter still exists because t is still polymorphic, but you
cannot do anything with it unless you match against the cases. Now,
"any" goes a step further, and even discards this parameter. It's a
matter of perspective: if 'a is case-dependent but not dependent to
anything outside t, you can also consider t as monomorphic. In other
words: Knowing all cases binds 'a. 

You need Any if you want to put several t values into a container, e.g.

Does not work: [ Int 34; Bool true ]
Does work:     [ Any(Int 34); Any(Bool true) ]

This nice thing with GADTs is that you can "undo" this change of
perspective by matching against the cases:

let print = ... (* as you defined it *)
let print_any (Any x) = print x
let () =
  List.iter print_any [ Any(Int 34); Any(Bool true) ]
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>OCamp - Reactive programming in the shell</cwn_title>
      <cwn_url>https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00005.html</cwn_url>
      <cwn_who>Frédéric Bour announced</cwn_who>
      <cwn_what>
OCamp extends unix shells with constructions to express memoization, sharing
of computations and reactive programming.

# Subcommands

## fire

Just wrap a unix command with "ocamp fire" to enable the extension:
  $ ocamp fire bash

This will spawn a new bash session where the following subcommands are
enabled.

## hipp

  $ ocamp hipp &lt;command&gt;

Will memoize the output and exit status of &lt;command&gt;.
Later calls to the same &lt;command&gt; won't lead to actual execution, but just to
a duplication of its previous output.
Concurrent calls to &lt;command&gt; will just share the same process, the beginning
of the output being replayed to later callers.

The identity of a command is defined by its arguments and working directory.

## stir

  $ ocamp stir &lt;command&gt;

Indicate potential changes in the output if &lt;command&gt; was rerun.
Later calls to `hipp` will recompute &lt;command&gt; as if it was not yet memoized.

## (un)follow

  $ ocamp follow &lt;command&gt;

First, &lt;command&gt; is memoized if it was not the case yet.
Then changes to dependencies of &lt;command&gt; will trigger a reevaluation.
Use `stir` to notify a change.

(to follow is an hipp/stir reactivity).

## pull

  $ ocamp pull &lt;command&gt;

Closely related to `hipp`, but instead of marking dependency on the output of
&lt;command&gt;, the dependency applies to the "effects" of &lt;command&gt;.

Thus, if `stir` is used:
- all pullers will be reevaluated.
- hippers will be reevaluated only if the output is different.

## Summary

  $ ocamp fire &lt;command&gt; - setup a new session alive until &lt;command&gt; exits
          pull &lt;command&gt; - mark dependency on effects of &lt;command&gt;
          hipp &lt;command&gt; - mark dependency on output of &lt;command&gt;
          stir &lt;command&gt; - notify that &lt;command&gt; might have been updated
          follow &lt;command&gt; - eval &lt;command&gt;, and reactively recompute it
                             whenever one of its dependencies change.
          unfollow &lt;command&gt; - stop recomputing &lt;command&gt; when dependencies
                               change

hipp and pull provide memoization.
stir and follow bring a flavor of reactive programming.

# Examples

## Fibonacci

  $ cat fib.sh
  #!/bin/sh
  ARG="$1"
  if [ "$ARG" -le 1 ]; then
    echo "$ARG"
  else
    A=`ocamp hipp ./fib.sh $((ARG-1))`
    B=`ocamp hipp ./fib.sh $((ARG-2))`
    echo $((A+B))
  fi

  $ time ocamp fire ./fib.sh 50
  12586269025
    real    0m0.391s
  user    0m0.153s
  sys     0m0.060s

## Build-system

`ocamp` provides simple primitives to construct and manage a dependency graph.

This might be a saner foundation to base a build-system on than make(1):
- the command focus on one specific problem
- no dsl is involved; rules can be plain unix commands, including a shell,
rather than a make-flavored simulation of shell
- nothing is provided for resolving goals; indeed this is better left to tools
specifically built for goal-search.

A quick'n'dirty script building ocamp itself is provided as an example.

# Future

The current release is a proof-of-concept and should be considered alpha
quality.
The two features planned next are a way to make the graph persistent (all data
is kept in memory atm) and an interface to debug and/or observe graph
construction.

Note: code is undergoing legal review and should be available soon \o/
      </cwn_what>
      <cwn_who>He later added</cwn_who>
      <cwn_what>
Code is finally available at:
    https://github.com/def-lkb/ocamp
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>Mathematical Expression Library</cwn_title>
      <cwn_url>https://sympa.inria.fr/sympa/arc/caml-list/2015-04/msg00013.html</cwn_url>
      <cwn_who>Kenneth Adam Miller asked</cwn_who>
      <cwn_what>
Is there a library somewhere where I can represent and simplify simple bit
operation expressions? Add, subtract, exclusive or, or, and, divide, multiply,
modulus, composed recursively, and operations on the expression type, such as
simplify?
      </cwn_what>
      <cwn_who>Ashish Agarwal replied</cwn_who>
      <cwn_what>
If you don't find anything else, maybe some of our old code from PADL 2010 can
help as a starting point [1]. Probably it'll be easier to put something
together from scratch, assuming you don't care about performance or need
variables.

[1] http://ashishagarwal.org/2010/01/18/automating-mp-transformations/
      </cwn_what>
      <cwn_who>Ivan Gotovchits suggested</cwn_who>
      <cwn_what>
If the expression, that you’re trying to simplify is actually a BAP’s BIL,
then there’re some optimizations in the `Bil` module. The most interesting is
constant folding and purging unused variables. You can also use fixpoint
function to drive the optimization passes. 

In any case, even if it is not a BIL, you can look at BAP’s constant folder
class. 
      </cwn_what>
      <cwn_who>Markus Weißmann also suggested</cwn_who>
      <cwn_what>
Just for completeness sake: There is also the "boolean expression simplifier"
[1] library implementing the Quine-McCluskey algorithm (and friends) in pure
OCaml.
I'd guess that a decent SMT solver will solve the "raw" expression much faster
than running it through the simplifier and then solving it (with the same
solver).

regards
Markus

[1] http://bes.forge.ocamlcore.org/
      </cwn_what>
    </cwn_entry>
    <cwn_entry>
      <cwn_title>Other OCaml News</cwn_title>
      <cwn_who>From the ocamlcore planet blog</cwn_who>
      <cwn_what>
Thanks to Alp Mestan, we now include in the OCaml Weekly News the links to the
recent posts from the ocamlcore planet blog at &lt;http://planet.ocaml.org/&gt;.

Ideal finger 001:
  &lt;http://erratique.ch/log/2015-04-05&gt;

Towards Heroku for Unikernels: Part 2 - Self Scaling Systems:
  &lt;http://amirchaudhry.com/heroku-for-unikernels-pt2&gt;

Another PhD position in Ljubljana:
  &lt;http://math.andrej.com/2015/04/03/another-phd-position-in-ljubljana/&gt;

Reviewing the second year of OCaml Labs in 2014:
  &lt;http://anil.recoil.org/2015/04/02/ocamllabs-2014-review.html&gt;

Pearl No.3 - Saddleback Search:
  &lt;http://typeocaml.com/2015/03/31/pearl-no-3-saddleback-search/&gt;

Towards Heroku for Unikernels: Part 1 - Automated deployment:
  &lt;http://amirchaudhry.com/heroku-for-unikernels-pt1&gt;
      </cwn_what>
    </cwn_entry>
  </cwn_body>
</cwn>
